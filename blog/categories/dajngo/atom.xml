<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Dajngo | 夕阳还是很红]]></title>
  <link href="http://shangyajun6943.github.io/blog/categories/dajngo/atom.xml" rel="self"/>
  <link href="http://shangyajun6943.github.io/"/>
  <updated>2018-07-06T17:03:14+08:00</updated>
  <id>http://shangyajun6943.github.io/</id>
  <author>
    <name><![CDATA[尚亚军]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Django-request对象]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_Django_5/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_Django_5</id>
    <content type="html"><![CDATA[<h1>Django-Django-request对象属性</h1>

<ul>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django-通用视图DetailView]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_Django_4/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_Django_4</id>
    <content type="html"><![CDATA[<h1>Django-通用视图DetailView</h1>

<h3>类图</h3>

<ul>
<li>url.py
<code>
urlpatterns = [
  re_path('getone/(?P&lt;id3&gt;[0-9]{1,10})',GetOneProduct.as_view()),
]
</code></li>
<li>view.py
<code>
class GetOneProduct(DetailView):
  model=Product
  template_name='product/showone.html'
  context_object_name='pro_one'
  pk_url_kwarg='id3'
</code></li>
</ul>


<p><strong>常用参数</strong></p>

<ul>
<li>model  必须指定模型，但会是这个模型下的所有的数据</li>
<li>queryset=？  指定的通过模型语言返回指定的QuerySet集合</li>
<li>template_name 指定返回的模板的地址</li>
<li>context_object_name 指定模板语言中返回的变量名称，默认是object_list</li>
<li>slug_url_kwarg = &lsquo;slug&rsquo; 指定url中配置中的名称</li>
<li>pk_url_kwarg = &lsquo;pk'指定url配置中的的名称</li>
<li><strong>因为DetailView只能返回一条数据，所以必须接受url传来的数据，默认数据的名称只能是pk或sulg，写成其他会报错，若果想用其他名称 重写get_object方法</strong></li>
<li>query_pk_and_slug = False 是否使用上面两个名称</li>
<li>http_method_names   http访问方式。包含了GET、POST等
<strong>常重写的方法</strong></li>
<li><p>额外的添加数据get_context_data方法
```
def  get_context_data(self,**kwargs):</p>

<pre><code>  context=super(ProductList,self).get_context_data(**kwargs)

  context['author_list']=Author.authors.all()

  return context
</code></pre>

<p>```</p></li>
<li><p>返回的数据集get_queryset（如果想快速查找必须重写这个方法，若果你看了get_object源码你就必须重写）
<code>
def get_queryset(self):
       return Product.products.filter(pk__gt=3)
</code>
这个方法重写就不用写model和queryset的中的值,但是要是排序时候这个方法不能重写</p></li>
<li><p>从url中获取参数，返回指定的数据集
<strong>url.py</strong>
<code>
re_path('list/([0-9]+)/([0-9]+)/([0-9]+)',ProductOne.as_view()),
</code>
<strong>view.py</strong>
```
def get_queryset(self):
  print(self.args)
  return Product.products.get(pk=int(self.args[0]))</p></li>
</ul>


<p>```
其中：self.args存放的就是url（get方法）传送到服务器上的值</p>

<ul>
<li>get_context_object_name
返回上下文的名称，context_object_name的值。默认为’数据对象’_list
-dispatch
返回处理请求的函数，此函数为继承后用户定义，匹配http_method_names中声明的名称。如果对应请求类型的函数不存在，则触发http_method_not_allowed函数，返回状态吗405</li>
</ul>


<p>-render_to_response
调用response_class返回渲染后的模板。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django-通用视图ListView]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_Django_3/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_Django_3</id>
    <content type="html"><![CDATA[<h1>Django-通用视图ListView</h1>

<h3>类图</h3>

<p><img src="/images/lsitviewimage.png" alt="image" /></p>

<ul>
<li>url.py
<code>
urlpatterns = [
  path('list/',ProductList.as_view()),
]
</code></li>
<li>view.py
<code>
class ProductList(ListView):
  model=Product
  queryset=Product.products.filter(pk__lt=3)
  template_name='product/listpro1.html'
  context_object_name='pro_lists'
  ordering=('-id',)
  paginate_by=2
</code></li>
</ul>


<p><strong>常用参数</strong></p>

<p>model  必须指定模型，但会是这个模型下的所有的数据
queryset=？  指定的通过模型语言返回指定的QuerySet集合
template_name 指定返回的模板的地址
context_object_name 指定模板语言中返回的变量名称，默认是object_list
ording 返回的数据集合按照什么排序（元组数据）
paginate_by 分页的参数，指定后会返回指定数量的数据
http_method_names   http访问方式。包含了GET、POST等
<strong>常重写的方法</strong>
- 额外的添加数据get_context_data方法
```
def  get_context_data(self,**kwargs):</p>

<pre><code>    context=super(ProductList,self).get_context_data(**kwargs)

    context['author_list']=Author.authors.all()

    return context
</code></pre>

<pre><code>- 返回的数据集get_queryset
</code></pre>

<p>def get_queryset(self):
         return Product.products.filter(pk__gt=3)
```
这个方法重写就不用写model和queryset的中的值,但是要是排序时候这个方法不能重写</p>

<ul>
<li><p>从url中获取参数，返回指定的数据集
<strong>url.py</strong>
<code>
re_path('list/([0-9]+)/([0-9]+)/([0-9]+)',ProductOne.as_view()),
</code>
<strong>view.py</strong>
```
class ProductOne(ListView):
  # model=Product
  template_name=&lsquo;product/Onepro1.html&rsquo;
  context_object_name=&lsquo;pro_one&rsquo;</p>

<p>  def get_queryset(self):
      print(self.args)
      print(int(self.args[0]))
      return Product.products.filter(pk__gt=int(self.args[0]))</p></li>
</ul>


<p>```
其中：self.args存放的就是url（get方法）传送到服务器上的值</p>

<ul>
<li>get_ordering 方法重写
返回指定的排序，ordering的值</li>
<li>get_allow_empty
返回get_allow_empty的值，True或False。默认为True</li>
<li>get_context_object_name
返回上下文的名称，context_object_name的值。默认为’数据对象’_list
-dispatch
返回处理请求的函数，此函数为继承后用户定义，匹配http_method_names中声明的名称。如果对应请求类型的函数不存在，则触发http_method_not_allowed函数，返回状态吗405</li>
</ul>


<p>-render_to_response
调用response_class返回渲染后的模板。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建一个Django项目]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_Django_2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_Django_2</id>
    <content type="html"><![CDATA[<h1>搭建一个Django项目</h1>

<h2>1.下载Django</h2>

<pre><code>pip install django==1.8.13   此版本太低
pip install django==2.0.1

pip install django  按炸U给最新版本
</code></pre>

<ul>
<li>没有pip（*python自带了pip）
<code>
python -m pip install -U pip
</code></li>
<li>在网上下载<a href="https://www.djangoproject.com/download/">https://www.djangoproject.com/download/</a>
Django-2.0.1.tar.gz</li>
</ul>


<h2>2.安装虚拟环境virtualenv</h2>

<ul>
<li>安装    pip install virtualenv</li>
<li>创建工作区  virtualenv venv（任意名字）

<ul>
<li>可以在系统的任意目录下创建工作区（virtualenv 会切换默认的工作区）</li>
<li><p>选择使用一个Python解释器：</p></li>
<li><p>virtualenv -p F:\python\Python36 venv</p></li>
<li>-p参数指定Python解释器程序路径</li>
</ul>
</li>
<li>进入工作区后dir或ls

<ul>
<li>Scripts\activate</li>
<li>退出工作区：Scripts\deactivate</li>
</ul>
</li>
<li>创建项目

<ul>
<li>django-admin startproject [项目名]</li>
</ul>
</li>
<li>创建应用

<ul>
<li>进入项目</li>
<li>Python manage.py startapp [应用名]</li>
</ul>
</li>
</ul>


<h2>3.使用模块</h2>

<ul>
<li>在项目的settings中添加自己的应用</li>
<li>编写自己应用的模块文件（models.py）中
<code>
class User(models.Model):
  username=models.CharField(max_length=40,unique=True)
  passwd=models.CharField(max_length=40)
  gender_choice=((0,'男'),(1,'女'))
  gender=models.IntegerField(default=0,choices=gender_choice)
  def __str__(self):
      return self.username
  class Meta:
      db_table='user'
</code></li>
<li>生成迁移
<code>
python manage.py makemigrations
</code></li>
<li>执行迁移
<code>
python manage.py migrate
</code></li>
<li>进入python解析器测试数据库
```
python manage.py shell</li>
</ul>


<pre><code>
##4.使用后台管理系统
### Django是做CMS系统出生，也是做CMS有优势，所以我们要使用Django中自带的后台，必须创建用户
- 命令行
</code></pre>

<p>python manage.py createsuperuser
```</p>

<ul>
<li>输入用户名、邮箱、密码2次</li>
<li><p>启动服务器
<code>
pyhton manage.py runserver
</code></p></li>
<li><p>在浏览器输入网址进入后台管理系统</p></li>
<li><a href="http://localhost:8000/admin/">http://localhost:8000/admin/</a>
或<a href="http://127.0.0.1:8000/admin/">http://127.0.0.1:8000/admin/</a></li>
</ul>


<h3>此时进入后台系统什么也看不到，因为我们没有关联models</h3>

<ul>
<li>在应用的admin.py中，先导入model，在编写models在后台显示的格式
```
from .models import UserInfo</li>
</ul>


<p>class UserInfoAdmin(admin.ModelAdmin):
list_display = [&lsquo;username&rsquo;, &lsquo;passwd&rsquo;, &lsquo;birthday&rsquo;,&lsquo;gender&rsquo;] 显示数据库中的数据的时候显示什么字段，可以点击列头进行排序
list_filter = [&lsquo;username&rsquo;]过滤字段，过滤框会出现在右侧
search_fields = [&lsquo;birthday&rsquo;]搜索字段，搜索框会出现在上侧
list_per_page = 10 分页，分页框会出现在下侧
fieldsets = [
        (&lsquo;basic&rsquo;, {&lsquo;fields&rsquo;: [&lsquo;username&rsquo;,&lsquo;birthdate&rsquo;]}),
        (&lsquo;more&rsquo;, {&lsquo;fields&rsquo;: [&lsquo;gender&rsquo;]}),
    ]</p>

<p>admin.site.register(UserInfo,UserInfoAdmin)把model注册到后台中能显示</p>

<p>```</p>

<ul>
<li>可以在settings.py中修改中文LANGUAGE_CODE = &lsquo;zh-hans或zh-hant‘</li>
<li>涉及到后台管理时间时，可以在Settings.py中设置时区
TIME_ZONE = &lsquo;Asia/Shanghai’</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django-视图url]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_Django_1/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_Django_1</id>
    <content type="html"><![CDATA[<h1>Django-视图与url</h1>

<p>在把Django项目创建完成之后</p>

<p>1.打开settings文件，把应用配置到项目上去</p>

<p>2.在应用中创建一个urls.py文件</p>

<p>3.在项目的urls文件中导入应用的urls文件，如下：
```
    from django.contrib import admin
    from django.urls import path,include</p>

<pre><code>urlpatterns = [
 path('admin/', admin.site.urls),
     path('food/', include('food.urls')),  #这一行
]
</code></pre>

<pre><code>4.编入应用自己的urls文件，如下：
from django.urls import path
from food.views import *

urlpatterns = [
    path('hello/',hello,name='hello'),
    path('time/',time,name='time'),
]

5.编写应用自己的views文件，
</code></pre>

<p>from django.shortcuts import render,HttpResponse</p>

<h1>Create your views here.</h1>

<p>def hello(request):
    return HttpResponse(&lsquo;1234&rsquo;)</p>

<p>```
render,HttpResponse？</p>

<p>render是在使用模板渲染html的时候使用，例如我们把从数据库中取到的数据显示到页面上，java使用的JSP技术
Django使用的模板（template），最总render还是调用HttpResponse，把html读取出来返回到浏览器（也可以说
render是HttpResponse的封装，功能强大而已），HttpResponse只能返回字符串，不能循环数据放到html中
所以使用render。</p>

<p>render为什么？一定要传入request呢？
1.request中存储的浏览器请求的数据类型
2.我们在模板中使用request这个对象，如：{{ request.path}}</p>
]]></content>
  </entry>
  
</feed>
