<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | 夕阳还是很红]]></title>
  <link href="http://shangyajun6943.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://shangyajun6943.github.io/"/>
  <updated>2018-08-16T23:47:42+08:00</updated>
  <id>http://shangyajun6943.github.io/</id>
  <author>
    <name><![CDATA[尚亚军]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Django-Django全文搜索]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_quanwen_2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_quanwen_2</id>
    <content type="html"><![CDATA[<h1>Django-Django全文搜索haystack</h1>

<h4>haystack官网：<a href="http://django-haystack.readthedocs.io/en/master/">http://django-haystack.readthedocs.io/en/master/</a></h4>

<h1>使用的工具</h1>

<ul>
<li>haystack是django的开源搜索框架，该框架支持Solr, Elasticsearch, Whoosh, Xapian搜索引擎，不用更改代码，直接切换引擎，减少代码量。</li>
<li>搜索引擎使用Whoosh，这是一个由纯Python实现的全文搜索引擎，没有二进制文件等，比较小巧，配置比较简单，当然性能自然略低。</li>
<li>中文分词Jieba，由于Whoosh自带的是英文分词，对中文的分词支持不是太好，故用jieba替换whoosh的分词组件。

<h1>配置说明</h1>

<h6>现在假设我们的项目叫做Project,有一个myapp的app，简略的目录结构如下。</h6>

<h3>此models.py的内容假设如下：</h3>

<pre><code>from django.db import models
from django.contrib.auth.models import User
class Note(models.Model):
  user = models.ForeignKey(User)
  pub_date = models.DateTimeField()
  title = models.CharField(max_length=200)
  body = models.TextField()
  def __str__(self):
      return self.title
</code></pre></li>
</ul>


<h2>1.首先安装各工具</h2>

<pre><code>pip install whoosh django-haystack jieba
</code></pre>

<h2>2.添加 Haystack 到Django的 INSTALLED_APPS</h2>

<pre><code>INSTALLED_APPS = [ 
        'django.contrib.admin',
        'django.contrib.auth', 
        'django.contrib.contenttypes', 
        'django.contrib.sessions', 
        'django.contrib.sites',
          # Added. haystack先添加，
          'haystack', 
          # Then your usual apps... 自己的app要写在haystakc后面
          'blog',
]
</code></pre>

<h2>3.修改 你的 settings.py，以配置引擎</h2>

<pre><code>HAYSTACK_CONNECTIONS = {
    'default': {
        'ENGINE': 'haystack.backends.whoosh_backend.WhooshEngine',
        'PATH': os.path.join(os.path.dirname(__file__), 'whoosh_index'),
    },
}
</code></pre>

<h6>其中顾名思义，ENGINE为使用的引擎必须要有，如果引擎是Whoosh，则PATH必须要填写，其为Whoosh 索引文件的存放文件夹。其他引擎的配置见官方文档<a href="http://django-haystack.readthedocs.io/en/master/">http://django-haystack.readthedocs.io/en/master/</a></h6>

<h2>4.创建索引</h2>

<h6>如果你想针对某个app例如mainapp做全文检索，则必须在mainapp的目录下面建立search_indexes.py文件，文件名不能修改。内容如下：</h6>

<pre><code>import datetime
from haystack import indexes
from myapp.models import Note
class NoteIndex(indexes.SearchIndex, indexes.Indexable):
    text = indexes.CharField(document=True, use_template=True)
    author = indexes.CharField(model_attr='user')
    pub_date = indexes.DateTimeField(model_attr='pub_date')
    def get_model(self):
        return Note
    def index_queryset(self, using=None):
        """Used when the entire index for model is updated."""
        return self.get_model().objects.filter(pub_date__lte=datetime.datetime.now())
</code></pre>

<h6>每个索引里面必须有且只能有一个字段为document=True，这代表haystack 和搜索引擎将使用此字段的内容作为索引进行检索(primary field)。其他的字段只是附属的属性，方便调用，并不作为检索数据。</h6>

<h6>注意：如果使用一个字段设置了document=True，则一般约定此字段名为text，这是在SearchIndex类里面一贯的命名，以防止后台混乱，当然名字你也可以随便改，不过不建议改。</h6>

<h6>并且，haystack提供了use_template=True在text字段，这样就允许我们使用数据模板去建立搜索引擎索引的文件，使用方便（官方推荐，当然还有其他复杂的建立索引文件的方式，目前我还不知道），数据模板的路径为yourapp/templates/search/indexes/yourapp/note_text.txt，例如本例子为blog/templates/search/indexes/blog/note_text.txt文件名必须为要索引的类名_text.txt,其内容为</h6>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"></pre></td><td class='code'><pre><code class=''></code></pre></td></tr></table></div></figure></p>

<h6>这个数据模板的作用是对Note.title, Note.user.get_full_name,Note.body这三个字段建立索引，当检索的时候会对这三个字段做全文检索匹配。</h6>

<h3>在urls.py中配置如下url信息，当然url路由可以随意写。</h3>

<pre><code>(r'^search/', include('haystack.urls')),
</code></pre>

<h6>其实haystack.urls的内容为，</h6>

<pre><code>from django.conf.urls import url
from haystack.views import SearchView
urlpatterns = [
    url(r'^$', SearchView(), name='haystack_search'),
]
</code></pre>

<h6>SearchView()视图函数默认使用的html模板为当前app目录下，路径为myapp/templates/search/search.html</h6>

<h6>所以需要在blog/templates/search/下添加search.html文件，自带了分页,内容为</h6>

<h6><a href="http://django-haystack.readthedocs.io/en/master/tutorial.html#handling-data">http://django-haystack.readthedocs.io/en/master/tutorial.html#handling-data</a></h6>

<h2>5.重建索引文件</h2>

<h3>使用python manage.py rebuild_index或者使用update_index命令。</h3>

<h2>6. 使用jieba分词</h2>

<h6># 1.将文件whoosh_backend.py（该文件路径为python路径/lib/python3.4/site-packages/haystack/backends/whoosh_backend.py）拷贝到app下面，并重命名为whoosh_cn_backend.py，例如blog/whoosh_cn_backend.py。修改如下添加from jieba.analyse import ChineseAnalyzer修改为如下</h6>

<pre><code>schema_fields[field_class.index_fieldname] =
    TEXT(stored=True, analyzer=ChineseAnalyzer(),
            field_boost=field_class.boost)
</code></pre>

<h3>2. 在settings.py中修改引擎，如下</h3>

<pre><code>HAYSTACK_CONNECTIONS = {
    'default': {
        'ENGINE': 'blog.whoosh_cn_backend.WhooshEngine',
        'PATH': os.path.join(BASE_DIR, 'whoosh_index'
    },
}
</code></pre>

<h3>3.重建索引，在进行搜索中文试试吧。</h3>

<h1>索引自动更新</h1>

<h6>如果没有索引自动更新，那么每当有新数据添加到数据库，就要手动执行update_index命令是不科学的。自动更新索引的最简单方法在settings.py添加一个信号。</h6>

<pre><code>HAYSTACK_SIGNAL_PROCESSOR =
            "haystack.signals.RealtimeSignalProcesso"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django-全文检索]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_quanwen_1/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_quanwen_1</id>
    <content type="html"><![CDATA[<h1>Django-全文检索概念</h1>

<p>-概念</p>

<h6>全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。全文搜索搜索引擎数据库中的数据。</h6>

<ul>
<li>方法

<h6>主要分为按字检索和按词检索两种。按字检索是指对于文章中的每一个字都建立索引，检索时将词分解为字的组合。按词检索指对文章中的词，即语义单位建立索引，检索时按词检索，并且可以处理同义项等。</h6></li>
</ul>


<p>-搜索引擎分类</p>

<h3>全文搜索、目录搜索、元搜索、垂直搜索</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress环境的搭建]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_octopress2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_octopress2</id>
    <content type="html"><![CDATA[<h1>octopress环境的搭建</h1>

<h3>git、ruby、Devkit、markdownPad的安装与配置</h3>

<ul>
<li>git：版本管理工具，将代码托管到github上</li>
<li>Ruby+Devkit：生成静态的页面</li>
<li>MarkdwonPad:z在window下Markdown语法编辑器</li>
</ul>


<h2>1.    git安装与配置</h2>

<h2>2.    ruby安装与配置</h2>

<h2>3.    Devkit安装与配置</h2>

<h2>4.    Ruby与Devkit关联</h2>

<h2>5.安装octopress并设置默认主题</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy - NumPy - 数据类型②]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy3/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy3</id>
    <content type="html"><![CDATA[<h1>NumPy - 数据类型</h1>

<ol>
<li>bool_   存储为一个字节的布尔值(真或假)</li>
<li>int_    默认整数，相当于 C 的long，通常为int32或int64</li>
<li>intc    相当于 C 的int，通常为int32或int64</li>
<li>intp    用于索引的整数，相当于 C 的size_t，通常为int32或int64</li>
<li>int     8字节(-128 ~ 127)</li>
<li>int16   16位整数(-32768 ~ 32767)</li>
<li>int32   32位整数(-2147483648 ~ 2147483647)</li>
<li>int64   64位整数(-9223372036854775808 ~ 9223372036854775807)</li>
<li>uint8   8位无符号整数(0 ~ 255)</li>
<li>uint16  16位无符号整数(0 ~ 65535)</li>
<li>uint32  32位无符号整数(0 ~ 4294967295)</li>
<li>uint64  64位无符号整数(0 ~ 18446744073709551615)</li>
<li>float_  float64的简写</li>
<li>float16 半精度浮点：符号位，5 位指数，10 位尾数</li>
<li>float32 单精度浮点：符号位，8 位指数，23 位尾数</li>
<li>float64 双精度浮点：符号位，11 位指数，52 位尾数</li>
<li>complex_complex 128的简写</li>
<li>complex64   复数，由两个 32 位浮点表示(实部和虚部)</li>
<li>complex128  复数，由两个 64 位浮点表示(实部和虚部)

<h4>NumPy 数字类型是dtype(数据类型)对象的实例，每个对象具有唯一的特征。 这些类型可以是np.bool_，np.float32等。</h4></li>
</ol>


<hr />

<h3>数据类型对象 (dtype)</h3>

<h4>数据类型对象描述了对应于数组的固定内存块的解释，取决于以下方面：</h4>

<ul>
<li><p>数据类型(整数、浮点或者 Python 对象)</p></li>
<li><p>数据大小</p></li>
<li><p>字节序(小端或大端)</p></li>
<li><p>在结构化类型的情况下，字段的名称，每个字段的数据类型，和每个字段占用的内存块部分。</p></li>
<li><p>如果数据类型是子序列，它的形状和数据类型。</p></li>
<li><p>字节顺序取决于数据类型的前缀&lt;或>。&lt;意味着编码是小端(最小有效字节存储在最小地址中)。>意味着编码是大端(最大有效字节存储在最小地址中)。</p></li>
</ul>


<h4>dtype可由一下语法构造：</h4>

<pre><code>numpy.dtype(object, align, copy)
</code></pre>

<h4>参数为：</h4>

<ul>
<li><p>Object：被转换为数据类型的对象。</p></li>
<li><p>Align：如果为true，则向字段添加间隔，使其类似 C 的结构体。</p></li>
<li><p>Copy? 生成dtype对象的新副本，如果为flase，结果是内建数据类型对象的引用。</p></li>
</ul>


<h3>示例 像创建列名一样创建数组</h3>

<pre><code>dt = np.dtype([('age',bool)])
a = np.array([12,13,14],dtype=dt)
print(a)
[( True,) ( True,) ( True,)]
print(a['age'])
[ True  True  True]
dt = np.dtype([('age',int),('name',str)])
a = np.array([(12,'a'),(13,'b')],dtype=dt)
print(a)
[(12, '') (13, '')]
dt = np.dtype(('age',bool))
student = np.dtype([('name','S20'),  ('age',  'i1'),  ('marks',  'f4')])
a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
print(a)
[(b'abc', 21, 50.) (b'xyz', 18, 75.)]
student = np.dtype([('name','str'),  ('age',  int),  ('marks',  float)])
a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
print(a)
[('', 21, 50.) ('', 18, 75.)]
 student = np.dtype([('name',str),  ('age',  int),  ('marks',  float)])
a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
print(a)
[('', 21, 50.) ('', 18, 75.)]
student = np.dtype([('name','a'),  ('age',  'i'),  ('marks',  'f')])
a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
print(a)
[(b'', 21, 50.) (b'', 18, 75.)]
student = np.dtype([('name','S'),  ('age',  'i'),  ('marks',  'f')])
a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
print(a)
[(b'', 21, 50.) (b'', 18, 75.)]
student = np.dtype([('name','S20'),  ('age',  'i'),  ('marks',  'f')])
a = np.array([[('abc',  21,  50),('xyz',  18,  75)],[('fff',  21,  50),('eee',  18,  75)]], dtype = student)
print(a)
[[(b'abc', 21, 50.) (b'xyz', 18, 75.)]
 [(b'fff', 21, 50.) (b'eee', 18, 75.)]]
print(a['name'])
[[b'abc' b'xyz']
 [b'fff' b'eee']]
</code></pre>

<h4>每个内建类型都有一个唯一定义它的字符代码：</h4>

<ul>
<li><p>&lsquo;b'：布尔值</p></li>
<li><p>&lsquo;i'：符号整数</p></li>
<li><p>&lsquo;u'：无符号整数</p></li>
<li><p>&lsquo;f'：浮点</p></li>
<li><p>&lsquo;c'：复数浮点</p></li>
<li><p>&rsquo;m'：时间间隔</p></li>
<li><p>&rsquo;M'：日期时间</p></li>
<li><p>&lsquo;O'：Python 对象</p></li>
<li><p>&rsquo;S', &lsquo;a'：字节串</p></li>
<li><p>&lsquo;U'：Unicode</p></li>
<li><p>&lsquo;V'：原始数据(void)</p></li>
</ul>


<h4><a href="https://www.yiibai.com/numpy/numpy_array_attributes.html">https://www.yiibai.com/numpy/numpy_array_attributes.html</a></h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy - Ndarray 对象①]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy2</id>
    <content type="html"><![CDATA[<h1>Ndarray 对象</h1>

<h4>NumPy 中定义的最重要的对象是称为 ndarray 的 N 维数组类型。 它描述相同类型的元素集合。 可以使用基于<code>零</code>的索引访问集合中的项目。</h4>

<h4>ndarray中的每个元素在内存中使用相同大小的块。 ndarray中的每个元素是数据类型对象的对象(称为 dtype)。</h4>

<h4>从ndarray对象提取的任何元素(通过切片)由一个数组标量类型的 Python 对象表示。 下图显示了ndarray，数据类型对象(dtype)和数组标量类型之间的关系。</h4>

<p><img src="/images/np/430090425_51678.jpg" alt="images" /></p>

<h4>基本的ndarray是使用 NumPy 中的数组函数创建的，如下所示：</h4>

<pre><code>numpy.array
</code></pre>

<h4>它从<code>任何暴露数组接口的对象</code>，或从返回数组的任何方法创建一个ndarray。</h4>

<pre><code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)
</code></pre>

<ol>
<li>object 任何暴露数组接口方法的对象都会返回一个数组或任何(嵌套)序列。</li>
<li>dtype 数组的所需数据类型，可选。</li>
<li>copy 可选，默认为true，对象是否被复制。</li>
<li>order C(按行)、F(按列)或A(任意，默认)。</li>
<li>subok 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类。</li>
<li>ndimin 指定返回数组的最小维数。</li>
</ol>


<h4>示例 1 一维数组</h4>

<pre><code>a = np.array([1,2,3])
print(a)
[1 2 3]
</code></pre>

<h4>示例 2 多维数组</h4>

<pre><code>a = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(a)
[[1 2 3]
[4 5 6]
[7 8 9]]
</code></pre>

<h4>示例 3 最小维度</h4>

<pre><code>a = np.array([1,2,3],ndmin=1)
print(a)
[1 2 3]
a = np.array([1,2,3],ndmin=2)
print(a)
[[1 2 3]]
a = np.array([1,2,3],ndmin=3)
print(a)
[[[1 2 3]]]
</code></pre>

<h4>示例 4 dtype 参数</h4>

<pre><code>a = np.array([1,2,3],dtype=complex)
print(a)
[1.+0.j 2.+0.j 3.+0.j]
a = np.array([1,2,3],dtype=int)
print(a)
[1 2 3]
a = np.array([1,2,3],dtype=str)
 print(a)
['1' '2' '3']
a = np.array([1,2,3],dtype=bool)
print(a)
[ True  True  True]
</code></pre>

<h2>ndarray 对象由计算机内存中的一维连续区域组成，带有将每个元素映射到内存块中某个位置的索引方案。 内存块以按行(C 风格)或按列(FORTRAN 或 MatLab 风格)的方式保存元素。</h2>
]]></content>
  </entry>
  
</feed>
