
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>夕阳还是很红</title>
  <meta name="author" content="尚亚军">

  
  <meta name="description" content="面试总结2 内存泄漏和内存溢出的区别和联系 1、内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。 2、内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用，或者说， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://shangyajun6943.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="夕阳还是很红" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">夕阳还是很红</a></h1>
  
    <h2>向前一小步，文明一大步</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.baidu.com" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="shangyajun6943.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/othew">othew</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/07/03/shangyajunblog_%E9%9D%A2%E8%AF%952/">面试总结2</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-07-03T15:11:11+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2018</span></span> <span class='time'>3:11 pm</span></time>
        
            
      </p>
    
  </header>


  <div class="entry-content"><h1>面试总结2</h1>

<hr />

<h5>内存泄漏和内存溢出的区别和联系</h5>

<h5>1、内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</h5>

<h5>2、内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</h5>

<h5>3、二者关系：</h5>

<ol>
<li>内存泄漏的堆积最终会导致内存溢出</li>
<li>内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。</li>
<li>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。</li>
<li>内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错，

<h5>4、内存泄漏的分类（按发生方式来分类）</h5></li>
<li>常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。</li>
<li>偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。</li>
<li>一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。</li>
<li>隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。</li>
</ol>


<h5>5、内存溢出的原因及解决方法：</h5>

<h5>内存溢出原因：</h5>

<ol>
<li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</li>
<li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；</li>
<li>代码中存在死循环或循环产生过多重复的对象实体；</li>
<li>使用的第三方软件中的BUG；</li>
<li>启动参数内存值设定的过小

<h5>内存溢出的解决方案：</h5>

<h5>第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</h5></li>
</ol>


<h5>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。</h5>

<h5>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。</h5>

<h4>重点排查以下几点：</h4>

<ol>
<li><p>检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</p></li>
<li><p>检查代码中是否有死循环或递归调用。</p></li>
<li><p>检查是否有大循环重复产生新对象实体。</p></li>
<li><p>检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</p></li>
</ol>


<h2><code>使用内存查看工具动态查看内存使用情况</code></h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/07/03/shangyajunblog_%E9%9D%A2%E8%AF%951/">面试总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-07-03T15:11:11+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2018</span></span> <span class='time'>3:11 pm</span></time>
        
            
      </p>
    
  </header>


  <div class="entry-content"><h1>面试总结</h1>

<hr />

<h5>1.list删除中pop、remove、del有什么区别？</h5>

<h5>pop是索引删除，不写参数默认是删除最后一个，返回值是删除的索引对应的值</h5>

<h5>remove是值删除，匹配的第一个匹配的值删除，没有返回值</h5>

<h5>del按照索引删除字符，返回值不可以付给其他的变量。</h5>

<h5>del list1 和list.clear()?</h5>

<hr />

<h5>2.map运行机制？</h5>

<h5>map()函数接受两个参数一个是函数，函数具有一个参数。一个是Iterable</h5>

<h5>map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</h5>

<h5>Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</h5>

<hr />
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/07/03/shangyajunblog_quanwen_2/">Django-Django全文搜索</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-07-03T15:11:11+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2018</span></span> <span class='time'>3:11 pm</span></time>
        
            
      </p>
    
  </header>


  <div class="entry-content"><h1>Django-Django全文搜索haystack</h1>

<h4>haystack官网：<a href="http://django-haystack.readthedocs.io/en/master/">http://django-haystack.readthedocs.io/en/master/</a></h4>

<h1>使用的工具</h1>

<ul>
<li>haystack是django的开源搜索框架，该框架支持Solr, Elasticsearch, Whoosh, Xapian搜索引擎，不用更改代码，直接切换引擎，减少代码量。</li>
<li>搜索引擎使用Whoosh，这是一个由纯Python实现的全文搜索引擎，没有二进制文件等，比较小巧，配置比较简单，当然性能自然略低。</li>
<li>中文分词Jieba，由于Whoosh自带的是英文分词，对中文的分词支持不是太好，故用jieba替换whoosh的分词组件。

<h1>配置说明</h1>

<h6>现在假设我们的项目叫做Project,有一个myapp的app，简略的目录结构如下。</h6>

<h3>此models.py的内容假设如下：</h3></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from django.db import models
</span><span class='line'>from django.contrib.auth.models import User
</span><span class='line'>class Note(models.Model):
</span><span class='line'>    user = models.ForeignKey(User)
</span><span class='line'>    pub_date = models.DateTimeField()
</span><span class='line'>    title = models.CharField(max_length=200)
</span><span class='line'>    body = models.TextField()
</span><span class='line'>    def __str__(self):
</span><span class='line'>        return self.title</span></code></pre></td></tr></table></div></figure>


<h2>1.首先安装各工具</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip install whoosh django-haystack jieba</span></code></pre></td></tr></table></div></figure>


<h2>2.添加 Haystack 到Django的 INSTALLED_APPS</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>INSTALLED_APPS = [ 
</span><span class='line'>        'django.contrib.admin',
</span><span class='line'>        'django.contrib.auth', 
</span><span class='line'>        'django.contrib.contenttypes', 
</span><span class='line'>        'django.contrib.sessions', 
</span><span class='line'>        'django.contrib.sites',
</span><span class='line'>          # Added. haystack先添加，
</span><span class='line'>          'haystack', 
</span><span class='line'>          # Then your usual apps... 自己的app要写在haystakc后面
</span><span class='line'>          'blog',
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>


<h2>3.修改 你的 settings.py，以配置引擎</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HAYSTACK_CONNECTIONS = {
</span><span class='line'>    'default': {
</span><span class='line'>        'ENGINE': 'haystack.backends.whoosh_backend.WhooshEngine',
</span><span class='line'>        'PATH': os.path.join(os.path.dirname(__file__), 'whoosh_index'),
</span><span class='line'>    },
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h6>其中顾名思义，ENGINE为使用的引擎必须要有，如果引擎是Whoosh，则PATH必须要填写，其为Whoosh 索引文件的存放文件夹。其他引擎的配置见官方文档<a href="http://django-haystack.readthedocs.io/en/master/">http://django-haystack.readthedocs.io/en/master/</a></h6>

<h2>4.创建索引</h2>

<h6>如果你想针对某个app例如mainapp做全文检索，则必须在mainapp的目录下面建立search_indexes.py文件，文件名不能修改。内容如下：</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import datetime
</span><span class='line'>from haystack import indexes
</span><span class='line'>from myapp.models import Note
</span><span class='line'>class NoteIndex(indexes.SearchIndex, indexes.Indexable):
</span><span class='line'>    text = indexes.CharField(document=True, use_template=True)
</span><span class='line'>    author = indexes.CharField(model_attr='user')
</span><span class='line'>    pub_date = indexes.DateTimeField(model_attr='pub_date')
</span><span class='line'>    def get_model(self):
</span><span class='line'>        return Note
</span><span class='line'>    def index_queryset(self, using=None):
</span><span class='line'>        """Used when the entire index for model is updated."""
</span><span class='line'>        return self.get_model().objects.filter(pub_date__lte=datetime.datetime.now())</span></code></pre></td></tr></table></div></figure>


<h6>每个索引里面必须有且只能有一个字段为document=True，这代表haystack 和搜索引擎将使用此字段的内容作为索引进行检索(primary field)。其他的字段只是附属的属性，方便调用，并不作为检索数据。</h6>

<h6>注意：如果使用一个字段设置了document=True，则一般约定此字段名为text，这是在SearchIndex类里面一贯的命名，以防止后台混乱，当然名字你也可以随便改，不过不建议改。</h6>

<h6>并且，haystack提供了use_template=True在text字段，这样就允许我们使用数据模板去建立搜索引擎索引的文件，使用方便（官方推荐，当然还有其他复杂的建立索引文件的方式，目前我还不知道），数据模板的路径为yourapp/templates/search/indexes/yourapp/note_text.txt，例如本例子为blog/templates/search/indexes/blog/note_text.txt文件名必须为要索引的类名_text.txt,其内容为</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\{\{ object.title \}\}\{\{ object.user.get_full_name \}\}
</span><span class='line'>  \{\{ object.body \}\}</span></code></pre></td></tr></table></div></figure>


<h6>这个数据模板的作用是对Note.title, Note.user.get_full_name,Note.body这三个字段建立索引，当检索的时候会对这三个字段做全文检索匹配。</h6>

<h3>在urls.py中配置如下url信息，当然url路由可以随意写。</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(r'^search/', include('haystack.urls')),</span></code></pre></td></tr></table></div></figure>


<h6>其实haystack.urls的内容为，</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from django.conf.urls import url
</span><span class='line'>from haystack.views import SearchView
</span><span class='line'>urlpatterns = [
</span><span class='line'>    url(r'^$', SearchView(), name='haystack_search'),
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>


<h6>SearchView()视图函数默认使用的html模板为当前app目录下，路径为myapp/templates/search/search.html</h6>

<h6>所以需要在blog/templates/search/下添加search.html文件，自带了分页,内容为</h6>

<h6><a href="http://django-haystack.readthedocs.io/en/master/tutorial.html#handling-data">http://django-haystack.readthedocs.io/en/master/tutorial.html#handling-data</a></h6>

<h2>5.重建索引文件</h2>

<h3>使用python manage.py rebuild_index或者使用update_index命令。</h3>

<h2>6. 使用jieba分词</h2>

<h6># 1.将文件whoosh_backend.py（该文件路径为python路径/lib/python3.4/site-packages/haystack/backends/whoosh_backend.py）拷贝到app下面，并重命名为whoosh_cn_backend.py，例如blog/whoosh_cn_backend.py。修改如下添加from jieba.analyse import ChineseAnalyzer修改为如下</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>schema_fields[field_class.index_fieldname] =
</span><span class='line'>    TEXT(stored=True, analyzer=ChineseAnalyzer(),
</span><span class='line'>            field_boost=field_class.boost)</span></code></pre></td></tr></table></div></figure>


<h3>2. 在settings.py中修改引擎，如下</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HAYSTACK_CONNECTIONS = {
</span><span class='line'>    'default': {
</span><span class='line'>        'ENGINE': 'blog.whoosh_cn_backend.WhooshEngine',
</span><span class='line'>        'PATH': os.path.join(BASE_DIR, 'whoosh_index'
</span><span class='line'>    },
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>3.重建索引，在进行搜索中文试试吧。</h3>

<h1>索引自动更新</h1>

<h6>如果没有索引自动更新，那么每当有新数据添加到数据库，就要手动执行update_index命令是不科学的。自动更新索引的最简单方法在settings.py添加一个信号。</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HAYSTACK_SIGNAL_PROCESSOR =
</span><span class='line'>            "haystack.signals.RealtimeSignalProcesso"</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/07/03/shangyajunblog_quanwen_1/">Django-全文检索</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-07-03T15:11:11+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2018</span></span> <span class='time'>3:11 pm</span></time>
        
            
      </p>
    
  </header>


  <div class="entry-content"><h1>Django-全文检索概念</h1>

<p>-概念</p>

<h6>全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。全文搜索搜索引擎数据库中的数据。</h6>

<ul>
<li>方法

<h6>主要分为按字检索和按词检索两种。按字检索是指对于文章中的每一个字都建立索引，检索时将词分解为字的组合。按词检索指对文章中的词，即语义单位建立索引，检索时按词检索，并且可以处理同义项等。</h6></li>
</ul>


<p>-搜索引擎分类</p>

<h3>全文搜索、目录搜索、元搜索、垂直搜索</h3>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/07/03/shangyajunblog_os2/">Os处理器状态</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-07-03T15:11:11+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2018</span></span> <span class='time'>3:11 pm</span></time>
        
            
      </p>
    
  </header>


  <div class="entry-content"><h1>处理器状态</h1>

<hr />

<h4>中央处理器（CPU）</h4>

<h5>处理器组成：运算器、控制器、一系列的<code>寄存器</code>、高速缓存</h5>

<h5>两种寄存器</h5>

<ol>
<li>用户可见寄存器：高级语言编译器通过优化算法分配并使用，以减少程序的访问内存的次数，提高运行效率</li>
<li>控制和状态寄存器：用于控制处理器的操作，通常由操作系统代码使用</li>
</ol>


<hr />

<h4>控制和状态寄存器</h4>

<ul>
<li>用于控制处理器的操作</li>
<li>在某种特权级别下可以访问、修改</li>
<li><p>常见的控制和状态寄存器：</p></li>
<li><p>程序计数器（PC：program Counter）：记录将取出的指令地址</p></li>
<li>指令寄存器（IR：Instruction Register）：记录最近取出的指令</li>
<li>程序状态字（PSW：Program Status Word）：记录处理器的运行状态如：条形码、模式、控制位等信息。</li>
</ul>


<hr />

<h4>现代CPU状态设计划分：两种、三种或四种</h4>

<h5>在程序状态字寄存器PSW中专门是指一位，根据运行程序<code>对资源和指令的使用权限</code>而设置不同的CPU状态</h5>

<h3>操作系统需要两种CPU状态</h3>

<ol>
<li>内核态：运行操作系统程序</li>
<li>用户态：运行用户程序</li>
</ol>


<h4>特权指令：只能有操作系统使用、用户程序不能使用的指令。启动IO、内存清零、修改程序状态字、设置时钟、允许/禁止中断、停机</h4>

<h4>非特权指令：用户程序可以使用的指令</h4>

<h3>X86支持4个处理器特权级别，特权环：R0-R3</h3>

<h4>R0相当于内核态，R3相当于用户态，R1和R2结余两者之间</h4>

<hr />

<h3>CPU状态之间的转换</h3>

<h6>用户态->内核态  唯一途径-> 中断/异常/陷入机制</h6>

<h6>内核态->用户态  设置程序状态字PSW</h6>

<h5>一条特殊的指令：陷入指令（又称访管指令）：提供给用户程序的接口，用于调用操作系统的功能（服务）。如：int、trap、syscall、sysenter/sysexit</h5>

<hr />

<h2>中断/异常机制</h2>

<h4>中断/异常：对于操作系统的重要性就好比：汽车的发动机、飞机的引擎，可以这么说：操作系统是由‘中断驱动’或者‘事件驱动’的</h4>

<h4>中断/异常：CPU对系统发生中的某个事件做出的一种反应，事件的发生改变了处理器的控制流</h4>

<h4>中断/异常：CPU暂停正在执行的程序，保留现场后自动转去执行相应的事件的处理程序，处理完成后返回断点，继续执行被打断的程序。</h4>

<h4>特点：随机发生、自动处理、和恢复</h4>

<h3>为什么引入中断与异常？</h3>

<h2>中断/异常合称：事件</h2>

<h3>事件分为：外中断（中断）、内中断（异常）</h3>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/07/03/shangyajunblog_os1/">操作系统</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-07-03T15:11:11+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2018</span></span> <span class='time'>3:11 pm</span></time>
        
            
      </p>
    
  </header>


  <div class="entry-content"><h1>操作系统怎么执行程序的？</h1>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>include &lt;stdio.h&gt;
</span><span class='line'>int main(int argc,char *argc[])
</span><span class='line'>{
</span><span class='line'>  puts("hello word!");
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>以这个程序为例，解释操作系统怎么调用程序！</h5>

<hr />

<ol>
<li>首先我们告诉操作系统我们执行helloworld程序(使用命令，或双击)</li>
<li>操作系统接受到用户请求，找到helloworld程序的相关信息，检查文件是否是可执行文件；并通过程序的首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。（可执行文件格式：window：pe linux：elf）</li>
<li>操作系统：创建一个进程，并将helloworld可执行文件映射到改进程结构，表示由该进程执行helloworld程序</li>
<li>操作系统：为helloworld程序设置CPU上下文环境并跳到程序开始处（假设调度程序选中了hello程序）</li>
<li>调度程序：执行helloworld程序的第一条指令，发生<code>缺页异常</code>（因为执行文件需要把程序读入内存）</li>
<li>操作系统：分配一页空闲的物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序（有时候程序很大，操作系统会多次从磁盘读程序进入内存，也会发生很多次缺页异常）</li>
<li>helloworld程序执行puts函数（系统调用），在显示器上写一字符串</li>
<li>操作系统：找到要将字符串宋往的显示设备，通常设备是由一个进程控制的，所以操作系统将写的字符串送给该进程</li>
<li>操作系统：控制设备的进程告诉设备的窗口系统它要显示的字符串，窗口系统确定知识一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区。</li>
<li>视频硬件将像素转换成显示器可接收的一组控制/数据信号</li>
<li>显示器解释信号，激发液晶屏</li>
<li>我们在屏幕上看到了‘helloworld’</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/07/03/shangyajunblog_octopress2/">Octopress环境的搭建</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-07-03T15:11:11+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2018</span></span> <span class='time'>3:11 pm</span></time>
        
            
      </p>
    
  </header>


  <div class="entry-content"><h1>octopress环境的搭建</h1>

<h3>git、ruby、Devkit、markdownPad的安装与配置</h3>

<ul>
<li>git：版本管理工具，将代码托管到github上</li>
<li>Ruby+Devkit：生成静态的页面</li>
<li>MarkdwonPad:z在window下Markdown语法编辑器</li>
</ul>


<h2>1.    git安装与配置</h2>

<h2>2.    ruby安装与配置</h2>

<h2>3.    Devkit安装与配置</h2>

<h2>4.    Ruby与Devkit关联</h2>

<h2>5.安装octopress并设置默认主题</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/07/03/shangyajunblog_linux3/">TCP详解</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-07-03T15:11:11+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2018</span></span> <span class='time'>3:11 pm</span></time>
        
            
      </p>
    
  </header>


  <div class="entry-content"><h1>TCP协议详解</h1>

<hr />

<h3>1.   传输层概述</h3>

<ul>
<li><p>TCP服务特点:面向连接、字节流、可靠传输</p>

<h5>TCP面向连接是什么意思？双方在同时使用TCP协议通信，必须先建立连接，然后才开始数据的读写，双发必须为这次连接分配必要的内核资源，以管理连接的状态和数据的传输，同时TCP协议模式是：全双工的，双方的多次读写可以使用一次连接进行，交换数据后双方必须断开连接，释放系统资源，TCP协议针对的是一对一的，基于广播，多播的应用，不能使用TCP，而使用UDP</h5></li>
<li><p>TCP头部信息</p></li>
</ul>


<hr />

<h3>2.   TCP状态转移详解</h3>

<hr />

<h3>3.   TCP简历简介和关闭连接的过程</h3>

<hr />

<h3>4.   RST复位报文段</h3>

<hr />

<h3>5.   TCP可靠性传输机制</h3>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/07/03/shangyajunblog_linux2/">TCP/IP协议族概述</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-07-03T15:11:11+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2018</span></span> <span class='time'>3:11 pm</span></time>
        
            
      </p>
    
  </header>


  <div class="entry-content"><h1>TCP/IP</h1>

<hr />

<h2>TCP/IP协议的体系结构</h2>

<ol>
<li><p>TCP/IP协议族四层模型和OSI七层模型</p>

<h5>OSI七层模型，物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</h5>

<h5>TCP/IP协议四层模型，链路层、网络层、传输层、应用层</h5>

<p><img src="/images/tcp_6.png" alt="image" /></p></li>
<li><p>四层模型中层次的作用和特点</p>

<h5>链路层：物理连接与传输(不同的类型？以太网，令牌)</h5>

<h5>网络层：数据包的选路与转发（IP层，数据包的选路和转发）</h5>

<h5>传输层：为两台机器提供了端到端的通信，关心传输的起始端和目标端，不在乎中专过程，主要完成数据分发，数据重传的任务</h5>

<p><img src="/images/tcp_7.png" alt="image" /></p></li>
<li><p>四层模型中层次中对应的协议</p>

<h5>链路层协议：1.ARP协议地址解析协议。2.RARP协议逆地址解析协议。已上两个实现了IP地址和物理地址的转换。</h5></li>
</ol>


<h5>网络层协议（必须把IP地址转化成物理地址才能使用链路层的服务）：1：IP协议：根据数据包的目的IP地址决定如何投递数据包，如果数据包不能直接发送给目标主机，IP协议会为数据包寻找合适的路由器，并把数据包给了路由器进行转发，一直重复，直到到大目的端或发送失败对齐数据包</h5>

<h5>2.ICMP协议：intel网控制报文协议，IP协议的重要补充，主要用于网络连接</h5>

<h5>3.IGMP</h5>

<h5>传输层协议：1.TCP协议，传中控制协议，它为应用层提供的可靠的、面向连接的、面向流的服务</h5>

<h5>2.UDP协议：为应用层提供不可靠的（无法保证正确的从发送端发送到目标端）、无连接的（不保持长久链接）、数据包（有长度，一次性读出）服务</h5>

<h5>3.SCTP协议：流控制传输协议，新的传输协议，控制intel网上电话信号设计的</h5>

<h5>应用层协议：1.telnet协议：远程登录协议</h5>

<h5>2.OSPF协议：开放路径最短优先协议，路由器更新协议，主要路由器之间的通信来告知对方各自的路由信息</h5>

<h5>3.DNS协议：提供机器域名到IP地址转换</h5>

<h5>ping</h5>

<hr />

<h2>数据的封装和分用</h2>

<ol>
<li>数据的封装形式</li>
</ol>


<p><img src="/images/tcp_1.png" alt="image" /></p>

<ol>
<li>TCP报文段的传输过程</li>
</ol>


<p><img src="/images/tcp_2.png" alt="image" /></p>

<ol>
<li>最大传送单元（MTU

<h5>在数据链路层传输的数据包称为帧，帧的最大单位称为MTU（Max Transmit Unit），以太网1500K，令牌1492K，超过最大单位就分片</h5></li>
<li>以太网帧格式</li>
</ol>


<p><img src="/images/tcp_3.png" alt="image" /></p>

<ol>
<li>数据分用的过程</li>
</ol>


<p><img src="/images/tcp_4.png" alt="image" /></p>

<h5>1.以太网帧在复杂的网络中如何选路？</h5>

<h5>2.网络协议怎么确保传输的数据准确无误的传输？</h5>

<hr />

<h2>ARP协议的工作原理</h2>

<ol>
<li>ARP的用途

<h5>1.ARP协议是地址解析协议</h5>

<h5>2.ARP协议作用：能实现网络地址到任意物理地址的转换</h5>

<h5>3.ARP工作原理：首先主机在自己所在的网络广播一个ARP请求，改请求包含目标机器的网络地址，同时网络上的其他机器都收到这个请求，但是只有被请求的目标机器回应一个ARP应答,其中包含了自己的物理地址</h5></li>
<li>ARP请求/应答报文详解</li>
</ol>


<p><img src="/images/tcp_5.png" alt="image" /></p>

<h2>3. ARP通信过程</h2>

<h2>DNS协议工作原理</h2>

<ol>
<li>DNS的用途和工作原理

<h5>DNS的作用：将机器的域名转换成IP地址（有很多方法转换，不至DNS一种）</h5>

<h5>DNS的工作原理：我们应用程序发送网址之前（使用的是TCP协议），必须将域名请求DNS服务器（端口53）找到域名对应的IP，才能使用TCP服务进行网络请求。DNS服务器就是一个分布式的IP存储系统。</h5></li>
<li>DNS查询和应答报文详解</li>
<li>Linux访问DNS服务</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/07/03/shangyajunblog_linux1/">Linux介绍</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2018-07-03T15:11:11+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2018</span></span> <span class='time'>3:11 pm</span></time>
        
            
      </p>
    
  </header>


  <div class="entry-content"><h1>Linux</h1>

<hr />

<h2>1.什么是Linux</h2>

<h5>1.关于Unux</h5>

<h5>2.什么是GNU和GPL</h5>

<h5>3.Linux起源</h5>

<hr />

<h2>2.Linux版本</h2>

<h5>1.Ubuntu，2004年9月发布，最为流行的<code>桌面</code>的Linux发行版。(个人)</h5>

<h5>2.RedHat,使用最广，性能稳定</h5>

<h5>3.CenOS，2003年底推出，rhel的重新编译版，免费（RedHat克隆出来的）服务器发行版</h5>

<hr />

<h2>Linux优缺点</h2>

<h5>优点</h5>

<ul>
<li>性能稳定()</li>
<li>较高的安全性和Bug的快速修复</li>
<li>支持多用户多任务</li>
<li>完善的用户和群组策略</li>
<li>资源好没底</li>
<li>适合嵌入式应用</li>
<li>免费或费用低廉

<h5>缺点</h5></li>
<li>专业软件支持不够</li>
<li>厂商的支持度不够</li>
<li>标准化不足</li>
</ul>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2018/07/03/shangyajunblog_%E9%9D%A2%E8%AF%952/">面试总结2</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/07/03/shangyajunblog_%E9%9D%A2%E8%AF%951/">面试总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/07/03/shangyajunblog_quanwen_2/">Django-Django全文搜索</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/07/03/shangyajunblog_quanwen_1/">Django-全文检索</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/07/03/shangyajunblog_os2/">Os处理器状态</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2018 - 尚亚军 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
