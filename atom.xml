<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[夕阳还是很红]]></title>
  <link href="http://shangyajun6943.github.io/atom.xml" rel="self"/>
  <link href="http://shangyajun6943.github.io/"/>
  <updated>2018-08-16T23:47:42+08:00</updated>
  <id>http://shangyajun6943.github.io/</id>
  <author>
    <name><![CDATA[尚亚军]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Docker容器]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/08/12/shangyajunblog_docker_2/"/>
    <updated>2018-08-12T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/08/12/shangyajunblog_docker_2</id>
    <content type="html"><![CDATA[<h1>Docker容器</h1>

<hr />

<h2>1. 容器的基本操作</h2>

<h4>启动容器docker</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>run [OPTIONS] IMAGE [COMMAND] [ARG...]</span></code></pre></td></tr></table></div></figure>


<h4>一次启动运行一次的容器，是docker中最基本的命令，运行完就结束</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run ubuntu echo 'hello world!'</span></code></pre></td></tr></table></div></figure>


<h4>启动交互式容器：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -i-t IMAGE /bin/bash
</span><span class='line'>-i 为容器提供标准的输入
</span><span class='line'>-t 为容器提供一个tty终端</span></code></pre></td></tr></table></div></figure>


<h4>查看我们创建的容器，和以前使用过的容器</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker ps [-a][-l]
</span><span class='line'>-a  -all 列出所有的容器
</span><span class='line'>-l  列出最新创建的容器
</span><span class='line'>
</span><span class='line'>sudo docker inspect [name|id] 可以查看指定docker的配置信息</span></code></pre></td></tr></table></div></figure>


<h4>创建自己名称docker容器</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run --name=[name] ubuntu echo 'hello world!'</span></code></pre></td></tr></table></div></figure>


<h4>重新启动停止的容器：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker start [-i] 容器名
</span><span class='line'>-i 表示重新启动停止的容器</span></code></pre></td></tr></table></div></figure>


<h4>删除不需要的容器(删除停止的容器，不能删除运行中的容器)</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker rm 容器名</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>2. 守护式容器</h2>

<h4>什么是守护式容器？在我们一开始创建了容器后，都是执行完命令后就容器停止了运行。但是守护式容器，不一样！！！！</h4>

<ol>
<li>能够长期运行</li>
<li>没有交互式会话</li>
<li>适合运行应用程序和服务</li>
</ol>


<h4>如何运行守护式容器呢？</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -i -t ubuntu /bin/bash
</span><span class='line'>使用ctrl+q或ctrl+p退出容器后，容器就会在后台运行</span></code></pre></td></tr></table></div></figure>


<h4>那么怎么再次进入运行在后台的容器呢？</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker attach [容器名]</span></code></pre></td></tr></table></div></figure>


<h4>启动守护式容器：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -d IMAGE [COMMAND] [ARG...]</span></code></pre></td></tr></table></div></figure>


<h4>查看容器的日志</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker logs [-f] [-t] [--tail] 容器名
</span><span class='line'>-f --follows=true|false 默认false 跟踪：一直更新日志
</span><span class='line'>-t --timestamps=true|false 默认false 显示时间戳
</span><span class='line'>--tail='all' 只显示最新的</span></code></pre></td></tr></table></div></figure>


<h4>查看容器中的进程</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker top 容器名</span></code></pre></td></tr></table></div></figure>


<h4>在运行中的容器中启动新的进程</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker exec [-d][-i][-t] 容器名[COMMAND] [ARG...]
</span><span class='line'>sudo docker exec -i -d 容器名 /bin/bash</span></code></pre></td></tr></table></div></figure>


<h4>停止守护式容器</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker stop 容器名  发送一个停止的信号给容器，等待容器停止
</span><span class='line'>docker kill 容器名  直接停止容器，不用等待</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>3. 在容器中部署静态网站</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker安装]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/08/12/shangyajunblog_docker_1/"/>
    <updated>2018-08-12T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/08/12/shangyajunblog_docker_1</id>
    <content type="html"><![CDATA[<h1>Docker安装</h1>

<hr />

<h2>1. 私有环境安装docker</h2>

<hr />

<h2>2. 公有环境安装docker</h2>

<h4>安装前的检查：</h4>

<h5>1.内核的检查</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>uname -a</span></code></pre></td></tr></table></div></figure>


<h5>2.检查Device Mapper的检查</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ls -l /sys/class/misc/device-mapper</span></code></pre></td></tr></table></div></figure>


<h4>安装docker维护的版本</h4>

<h5>1.检查APT的HTTPS支持查看文件是否存在</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/usr/lib/apt/methods/https</span></code></pre></td></tr></table></div></figure>


<h5>不存在：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>apt-get update
</span><span class='line'>pat-get install -y apt-transport-https</span></code></pre></td></tr></table></div></figure>


<h5>2.添加Docker的APT仓库</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo deb https://getdocker.com/ubuntu docker main &gt; /etc/apt/sources.list.d/docker.list</span></code></pre></td></tr></table></div></figure>


<h5>3. 添加仓库的key</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys </span></code></pre></td></tr></table></div></figure>


<h5>4. 安装</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>apt-get update
</span><span class='line'>apt-get install -y lxc-docker</span></code></pre></td></tr></table></div></figure>


<h2>安装简易的命令：</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get update
</span><span class='line'>sudo apt-get install \
</span><span class='line'>    apt-transport-https \
</span><span class='line'>    ca-certificates \
</span><span class='line'>    curl \
</span><span class='line'>    software-properties-common
</span><span class='line'>curl -fsSL https://get.docker.com -o get-docker.sh
</span><span class='line'>sudo sh get-docker.sh</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>3. 配置国内镜像仓库</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django-Django全文搜索]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_quanwen_2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_quanwen_2</id>
    <content type="html"><![CDATA[<h1>Django-Django全文搜索haystack</h1>

<h4>haystack官网：<a href="http://django-haystack.readthedocs.io/en/master/">http://django-haystack.readthedocs.io/en/master/</a></h4>

<h1>使用的工具</h1>

<ul>
<li>haystack是django的开源搜索框架，该框架支持Solr, Elasticsearch, Whoosh, Xapian搜索引擎，不用更改代码，直接切换引擎，减少代码量。</li>
<li>搜索引擎使用Whoosh，这是一个由纯Python实现的全文搜索引擎，没有二进制文件等，比较小巧，配置比较简单，当然性能自然略低。</li>
<li>中文分词Jieba，由于Whoosh自带的是英文分词，对中文的分词支持不是太好，故用jieba替换whoosh的分词组件。

<h1>配置说明</h1>

<h6>现在假设我们的项目叫做Project,有一个myapp的app，简略的目录结构如下。</h6>

<h3>此models.py的内容假设如下：</h3></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from django.db import models
</span><span class='line'>from django.contrib.auth.models import User
</span><span class='line'>class Note(models.Model):
</span><span class='line'>    user = models.ForeignKey(User)
</span><span class='line'>    pub_date = models.DateTimeField()
</span><span class='line'>    title = models.CharField(max_length=200)
</span><span class='line'>    body = models.TextField()
</span><span class='line'>    def __str__(self):
</span><span class='line'>        return self.title</span></code></pre></td></tr></table></div></figure>


<h2>1.首先安装各工具</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip install whoosh django-haystack jieba</span></code></pre></td></tr></table></div></figure>


<h2>2.添加 Haystack 到Django的 INSTALLED_APPS</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>INSTALLED_APPS = [ 
</span><span class='line'>        'django.contrib.admin',
</span><span class='line'>        'django.contrib.auth', 
</span><span class='line'>        'django.contrib.contenttypes', 
</span><span class='line'>        'django.contrib.sessions', 
</span><span class='line'>        'django.contrib.sites',
</span><span class='line'>          # Added. haystack先添加，
</span><span class='line'>          'haystack', 
</span><span class='line'>          # Then your usual apps... 自己的app要写在haystakc后面
</span><span class='line'>          'blog',
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>


<h2>3.修改 你的 settings.py，以配置引擎</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HAYSTACK_CONNECTIONS = {
</span><span class='line'>    'default': {
</span><span class='line'>        'ENGINE': 'haystack.backends.whoosh_backend.WhooshEngine',
</span><span class='line'>        'PATH': os.path.join(os.path.dirname(__file__), 'whoosh_index'),
</span><span class='line'>    },
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h6>其中顾名思义，ENGINE为使用的引擎必须要有，如果引擎是Whoosh，则PATH必须要填写，其为Whoosh 索引文件的存放文件夹。其他引擎的配置见官方文档<a href="http://django-haystack.readthedocs.io/en/master/">http://django-haystack.readthedocs.io/en/master/</a></h6>

<h2>4.创建索引</h2>

<h6>如果你想针对某个app例如mainapp做全文检索，则必须在mainapp的目录下面建立search_indexes.py文件，文件名不能修改。内容如下：</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import datetime
</span><span class='line'>from haystack import indexes
</span><span class='line'>from myapp.models import Note
</span><span class='line'>class NoteIndex(indexes.SearchIndex, indexes.Indexable):
</span><span class='line'>    text = indexes.CharField(document=True, use_template=True)
</span><span class='line'>    author = indexes.CharField(model_attr='user')
</span><span class='line'>    pub_date = indexes.DateTimeField(model_attr='pub_date')
</span><span class='line'>    def get_model(self):
</span><span class='line'>        return Note
</span><span class='line'>    def index_queryset(self, using=None):
</span><span class='line'>        """Used when the entire index for model is updated."""
</span><span class='line'>        return self.get_model().objects.filter(pub_date__lte=datetime.datetime.now())</span></code></pre></td></tr></table></div></figure>


<h6>每个索引里面必须有且只能有一个字段为document=True，这代表haystack 和搜索引擎将使用此字段的内容作为索引进行检索(primary field)。其他的字段只是附属的属性，方便调用，并不作为检索数据。</h6>

<h6>注意：如果使用一个字段设置了document=True，则一般约定此字段名为text，这是在SearchIndex类里面一贯的命名，以防止后台混乱，当然名字你也可以随便改，不过不建议改。</h6>

<h6>并且，haystack提供了use_template=True在text字段，这样就允许我们使用数据模板去建立搜索引擎索引的文件，使用方便（官方推荐，当然还有其他复杂的建立索引文件的方式，目前我还不知道），数据模板的路径为yourapp/templates/search/indexes/yourapp/note_text.txt，例如本例子为blog/templates/search/indexes/blog/note_text.txt文件名必须为要索引的类名_text.txt,其内容为</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\{\{ object.title \}\}\{\{ object.user.get_full_name \}\}
</span><span class='line'>  \{\{ object.body \}\}</span></code></pre></td></tr></table></div></figure>


<h6>这个数据模板的作用是对Note.title, Note.user.get_full_name,Note.body这三个字段建立索引，当检索的时候会对这三个字段做全文检索匹配。</h6>

<h3>在urls.py中配置如下url信息，当然url路由可以随意写。</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(r'^search/', include('haystack.urls')),</span></code></pre></td></tr></table></div></figure>


<h6>其实haystack.urls的内容为，</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from django.conf.urls import url
</span><span class='line'>from haystack.views import SearchView
</span><span class='line'>urlpatterns = [
</span><span class='line'>    url(r'^$', SearchView(), name='haystack_search'),
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>


<h6>SearchView()视图函数默认使用的html模板为当前app目录下，路径为myapp/templates/search/search.html</h6>

<h6>所以需要在blog/templates/search/下添加search.html文件，自带了分页,内容为</h6>

<h6><a href="http://django-haystack.readthedocs.io/en/master/tutorial.html#handling-data">http://django-haystack.readthedocs.io/en/master/tutorial.html#handling-data</a></h6>

<h2>5.重建索引文件</h2>

<h3>使用python manage.py rebuild_index或者使用update_index命令。</h3>

<h2>6. 使用jieba分词</h2>

<h6># 1.将文件whoosh_backend.py（该文件路径为python路径/lib/python3.4/site-packages/haystack/backends/whoosh_backend.py）拷贝到app下面，并重命名为whoosh_cn_backend.py，例如blog/whoosh_cn_backend.py。修改如下添加from jieba.analyse import ChineseAnalyzer修改为如下</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>schema_fields[field_class.index_fieldname] =
</span><span class='line'>    TEXT(stored=True, analyzer=ChineseAnalyzer(),
</span><span class='line'>            field_boost=field_class.boost)</span></code></pre></td></tr></table></div></figure>


<h3>2. 在settings.py中修改引擎，如下</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HAYSTACK_CONNECTIONS = {
</span><span class='line'>    'default': {
</span><span class='line'>        'ENGINE': 'blog.whoosh_cn_backend.WhooshEngine',
</span><span class='line'>        'PATH': os.path.join(BASE_DIR, 'whoosh_index'
</span><span class='line'>    },
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>3.重建索引，在进行搜索中文试试吧。</h3>

<h1>索引自动更新</h1>

<h6>如果没有索引自动更新，那么每当有新数据添加到数据库，就要手动执行update_index命令是不科学的。自动更新索引的最简单方法在settings.py添加一个信号。</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HAYSTACK_SIGNAL_PROCESSOR =
</span><span class='line'>            "haystack.signals.RealtimeSignalProcesso"</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django-全文检索]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_quanwen_1/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_quanwen_1</id>
    <content type="html"><![CDATA[<h1>Django-全文检索概念</h1>

<p>-概念</p>

<h6>全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。全文搜索搜索引擎数据库中的数据。</h6>

<ul>
<li>方法

<h6>主要分为按字检索和按词检索两种。按字检索是指对于文章中的每一个字都建立索引，检索时将词分解为字的组合。按词检索指对文章中的词，即语义单位建立索引，检索时按词检索，并且可以处理同义项等。</h6></li>
</ul>


<p>-搜索引擎分类</p>

<h3>全文搜索、目录搜索、元搜索、垂直搜索</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Os处理器状态]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_os2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_os2</id>
    <content type="html"><![CDATA[<h1>处理器状态</h1>

<hr />

<h4>中央处理器（CPU）</h4>

<h5>处理器组成：运算器、控制器、一系列的<code>寄存器</code>、高速缓存</h5>

<h5>两种寄存器</h5>

<ol>
<li>用户可见寄存器：高级语言编译器通过优化算法分配并使用，以减少程序的访问内存的次数，提高运行效率</li>
<li>控制和状态寄存器：用于控制处理器的操作，通常由操作系统代码使用</li>
</ol>


<hr />

<h4>控制和状态寄存器</h4>

<ul>
<li>用于控制处理器的操作</li>
<li>在某种特权级别下可以访问、修改</li>
<li><p>常见的控制和状态寄存器：</p></li>
<li><p>程序计数器（PC：program Counter）：记录将取出的指令地址</p></li>
<li>指令寄存器（IR：Instruction Register）：记录最近取出的指令</li>
<li>程序状态字（PSW：Program Status Word）：记录处理器的运行状态如：条形码、模式、控制位等信息。</li>
</ul>


<hr />

<h4>现代CPU状态设计划分：两种、三种或四种</h4>

<h5>在程序状态字寄存器PSW中专门是指一位，根据运行程序<code>对资源和指令的使用权限</code>而设置不同的CPU状态</h5>

<h3>操作系统需要两种CPU状态</h3>

<ol>
<li>内核态：运行操作系统程序</li>
<li>用户态：运行用户程序</li>
</ol>


<h4>特权指令：只能有操作系统使用、用户程序不能使用的指令。启动IO、内存清零、修改程序状态字、设置时钟、允许/禁止中断、停机</h4>

<h4>非特权指令：用户程序可以使用的指令</h4>

<h3>X86支持4个处理器特权级别，特权环：R0-R3</h3>

<h4>R0相当于内核态，R3相当于用户态，R1和R2结余两者之间</h4>

<hr />

<h3>CPU状态之间的转换</h3>

<h6>用户态->内核态  唯一途径-> 中断/异常/陷入机制</h6>

<h6>内核态->用户态  设置程序状态字PSW</h6>

<h5>一条特殊的指令：陷入指令（又称访管指令）：提供给用户程序的接口，用于调用操作系统的功能（服务）。如：int、trap、syscall、sysenter/sysexit</h5>

<hr />

<h2>中断/异常机制</h2>

<h4>中断/异常：对于操作系统的重要性就好比：汽车的发动机、飞机的引擎，可以这么说：操作系统是由‘中断驱动’或者‘事件驱动’的</h4>

<h4>中断/异常：CPU对系统发生中的某个事件做出的一种反应，事件的发生改变了处理器的控制流</h4>

<h4>中断/异常：CPU暂停正在执行的程序，保留现场后自动转去执行相应的事件的处理程序，处理完成后返回断点，继续执行被打断的程序。</h4>

<h4>特点：随机发生、自动处理、和恢复</h4>

<h3>为什么引入中断与异常？</h3>

<h2>中断/异常合称：事件</h2>

<h3>事件分为：外中断（中断）、内中断（异常）</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[操作系统]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_os1/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_os1</id>
    <content type="html"><![CDATA[<h1>操作系统怎么执行程序的？</h1>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>include &lt;stdio.h&gt;
</span><span class='line'>int main(int argc,char *argc[])
</span><span class='line'>{
</span><span class='line'>  puts("hello word!");
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>以这个程序为例，解释操作系统怎么调用程序！</h5>

<hr />

<ol>
<li>首先我们告诉操作系统我们执行helloworld程序(使用命令，或双击)</li>
<li>操作系统接受到用户请求，找到helloworld程序的相关信息，检查文件是否是可执行文件；并通过程序的首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。（可执行文件格式：window：pe linux：elf）</li>
<li>操作系统：创建一个进程，并将helloworld可执行文件映射到改进程结构，表示由该进程执行helloworld程序</li>
<li>操作系统：为helloworld程序设置CPU上下文环境并跳到程序开始处（假设调度程序选中了hello程序）</li>
<li>调度程序：执行helloworld程序的第一条指令，发生<code>缺页异常</code>（因为执行文件需要把程序读入内存）</li>
<li>操作系统：分配一页空闲的物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序（有时候程序很大，操作系统会多次从磁盘读程序进入内存，也会发生很多次缺页异常）</li>
<li>helloworld程序执行puts函数（系统调用），在显示器上写一字符串</li>
<li>操作系统：找到要将字符串宋往的显示设备，通常设备是由一个进程控制的，所以操作系统将写的字符串送给该进程</li>
<li>操作系统：控制设备的进程告诉设备的窗口系统它要显示的字符串，窗口系统确定知识一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区。</li>
<li>视频硬件将像素转换成显示器可接收的一组控制/数据信号</li>
<li>显示器解释信号，激发液晶屏</li>
<li>我们在屏幕上看到了‘helloworld’</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress环境的搭建]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_octopress2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_octopress2</id>
    <content type="html"><![CDATA[<h1>octopress环境的搭建</h1>

<h3>git、ruby、Devkit、markdownPad的安装与配置</h3>

<ul>
<li>git：版本管理工具，将代码托管到github上</li>
<li>Ruby+Devkit：生成静态的页面</li>
<li>MarkdwonPad:z在window下Markdown语法编辑器</li>
</ul>


<h2>1.    git安装与配置</h2>

<h2>2.    ruby安装与配置</h2>

<h2>3.    Devkit安装与配置</h2>

<h2>4.    Ruby与Devkit关联</h2>

<h2>5.安装octopress并设置默认主题</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy - NumPy - 数据类型②]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy3/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy3</id>
    <content type="html"><![CDATA[<h1>NumPy - 数据类型</h1>

<ol>
<li>bool_   存储为一个字节的布尔值(真或假)</li>
<li>int_    默认整数，相当于 C 的long，通常为int32或int64</li>
<li>intc    相当于 C 的int，通常为int32或int64</li>
<li>intp    用于索引的整数，相当于 C 的size_t，通常为int32或int64</li>
<li>int     8字节(-128 ~ 127)</li>
<li>int16   16位整数(-32768 ~ 32767)</li>
<li>int32   32位整数(-2147483648 ~ 2147483647)</li>
<li>int64   64位整数(-9223372036854775808 ~ 9223372036854775807)</li>
<li>uint8   8位无符号整数(0 ~ 255)</li>
<li>uint16  16位无符号整数(0 ~ 65535)</li>
<li>uint32  32位无符号整数(0 ~ 4294967295)</li>
<li>uint64  64位无符号整数(0 ~ 18446744073709551615)</li>
<li>float_  float64的简写</li>
<li>float16 半精度浮点：符号位，5 位指数，10 位尾数</li>
<li>float32 单精度浮点：符号位，8 位指数，23 位尾数</li>
<li>float64 双精度浮点：符号位，11 位指数，52 位尾数</li>
<li>complex_complex 128的简写</li>
<li>complex64   复数，由两个 32 位浮点表示(实部和虚部)</li>
<li>complex128  复数，由两个 64 位浮点表示(实部和虚部)

<h4>NumPy 数字类型是dtype(数据类型)对象的实例，每个对象具有唯一的特征。 这些类型可以是np.bool_，np.float32等。</h4></li>
</ol>


<hr />

<h3>数据类型对象 (dtype)</h3>

<h4>数据类型对象描述了对应于数组的固定内存块的解释，取决于以下方面：</h4>

<ul>
<li><p>数据类型(整数、浮点或者 Python 对象)</p></li>
<li><p>数据大小</p></li>
<li><p>字节序(小端或大端)</p></li>
<li><p>在结构化类型的情况下，字段的名称，每个字段的数据类型，和每个字段占用的内存块部分。</p></li>
<li><p>如果数据类型是子序列，它的形状和数据类型。</p></li>
<li><p>字节顺序取决于数据类型的前缀&lt;或>。&lt;意味着编码是小端(最小有效字节存储在最小地址中)。>意味着编码是大端(最大有效字节存储在最小地址中)。</p></li>
</ul>


<h4>dtype可由一下语法构造：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.dtype(object, align, copy)</span></code></pre></td></tr></table></div></figure>


<h4>参数为：</h4>

<ul>
<li><p>Object：被转换为数据类型的对象。</p></li>
<li><p>Align：如果为true，则向字段添加间隔，使其类似 C 的结构体。</p></li>
<li><p>Copy? 生成dtype对象的新副本，如果为flase，结果是内建数据类型对象的引用。</p></li>
</ul>


<h3>示例 像创建列名一样创建数组</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dt = np.dtype([('age',bool)])
</span><span class='line'>a = np.array([12,13,14],dtype=dt)
</span><span class='line'>print(a)
</span><span class='line'>[( True,) ( True,) ( True,)]
</span><span class='line'>print(a['age'])
</span><span class='line'>[ True  True  True]
</span><span class='line'>dt = np.dtype([('age',int),('name',str)])
</span><span class='line'>a = np.array([(12,'a'),(13,'b')],dtype=dt)
</span><span class='line'>print(a)
</span><span class='line'>[(12, '') (13, '')]
</span><span class='line'>dt = np.dtype(('age',bool))
</span><span class='line'>student = np.dtype([('name','S20'),  ('age',  'i1'),  ('marks',  'f4')])
</span><span class='line'>a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
</span><span class='line'>print(a)
</span><span class='line'>[(b'abc', 21, 50.) (b'xyz', 18, 75.)]
</span><span class='line'>student = np.dtype([('name','str'),  ('age',  int),  ('marks',  float)])
</span><span class='line'>a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
</span><span class='line'>print(a)
</span><span class='line'>[('', 21, 50.) ('', 18, 75.)]
</span><span class='line'> student = np.dtype([('name',str),  ('age',  int),  ('marks',  float)])
</span><span class='line'>a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
</span><span class='line'>print(a)
</span><span class='line'>[('', 21, 50.) ('', 18, 75.)]
</span><span class='line'>student = np.dtype([('name','a'),  ('age',  'i'),  ('marks',  'f')])
</span><span class='line'>a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
</span><span class='line'>print(a)
</span><span class='line'>[(b'', 21, 50.) (b'', 18, 75.)]
</span><span class='line'>student = np.dtype([('name','S'),  ('age',  'i'),  ('marks',  'f')])
</span><span class='line'>a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
</span><span class='line'>print(a)
</span><span class='line'>[(b'', 21, 50.) (b'', 18, 75.)]
</span><span class='line'>student = np.dtype([('name','S20'),  ('age',  'i'),  ('marks',  'f')])
</span><span class='line'>a = np.array([[('abc',  21,  50),('xyz',  18,  75)],[('fff',  21,  50),('eee',  18,  75)]], dtype = student)
</span><span class='line'>print(a)
</span><span class='line'>[[(b'abc', 21, 50.) (b'xyz', 18, 75.)]
</span><span class='line'> [(b'fff', 21, 50.) (b'eee', 18, 75.)]]
</span><span class='line'>print(a['name'])
</span><span class='line'>[[b'abc' b'xyz']
</span><span class='line'> [b'fff' b'eee']]</span></code></pre></td></tr></table></div></figure>


<h4>每个内建类型都有一个唯一定义它的字符代码：</h4>

<ul>
<li><p>&lsquo;b'：布尔值</p></li>
<li><p>&lsquo;i'：符号整数</p></li>
<li><p>&lsquo;u'：无符号整数</p></li>
<li><p>&lsquo;f'：浮点</p></li>
<li><p>&lsquo;c'：复数浮点</p></li>
<li><p>&rsquo;m'：时间间隔</p></li>
<li><p>&rsquo;M'：日期时间</p></li>
<li><p>&lsquo;O'：Python 对象</p></li>
<li><p>&rsquo;S', &lsquo;a'：字节串</p></li>
<li><p>&lsquo;U'：Unicode</p></li>
<li><p>&lsquo;V'：原始数据(void)</p></li>
</ul>


<h4><a href="https://www.yiibai.com/numpy/numpy_array_attributes.html">https://www.yiibai.com/numpy/numpy_array_attributes.html</a></h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy - Ndarray 对象①]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy2</id>
    <content type="html"><![CDATA[<h1>Ndarray 对象</h1>

<h4>NumPy 中定义的最重要的对象是称为 ndarray 的 N 维数组类型。 它描述相同类型的元素集合。 可以使用基于<code>零</code>的索引访问集合中的项目。</h4>

<h4>ndarray中的每个元素在内存中使用相同大小的块。 ndarray中的每个元素是数据类型对象的对象(称为 dtype)。</h4>

<h4>从ndarray对象提取的任何元素(通过切片)由一个数组标量类型的 Python 对象表示。 下图显示了ndarray，数据类型对象(dtype)和数组标量类型之间的关系。</h4>

<p><img src="http://shangyajun6943.github.io/images/np/430090425_51678.jpg" alt="images" /></p>

<h4>基本的ndarray是使用 NumPy 中的数组函数创建的，如下所示：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.array</span></code></pre></td></tr></table></div></figure>


<h4>它从<code>任何暴露数组接口的对象</code>，或从返回数组的任何方法创建一个ndarray。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</span></code></pre></td></tr></table></div></figure>


<ol>
<li>object 任何暴露数组接口方法的对象都会返回一个数组或任何(嵌套)序列。</li>
<li>dtype 数组的所需数据类型，可选。</li>
<li>copy 可选，默认为true，对象是否被复制。</li>
<li>order C(按行)、F(按列)或A(任意，默认)。</li>
<li>subok 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类。</li>
<li>ndimin 指定返回数组的最小维数。</li>
</ol>


<h4>示例 1 一维数组</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.array([1,2,3])
</span><span class='line'>print(a)
</span><span class='line'>[1 2 3]</span></code></pre></td></tr></table></div></figure>


<h4>示例 2 多维数组</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.array([[1,2,3],[4,5,6],[7,8,9]])
</span><span class='line'>print(a)
</span><span class='line'>[[1 2 3]
</span><span class='line'>[4 5 6]
</span><span class='line'>[7 8 9]]</span></code></pre></td></tr></table></div></figure>


<h4>示例 3 最小维度</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.array([1,2,3],ndmin=1)
</span><span class='line'>print(a)
</span><span class='line'>[1 2 3]
</span><span class='line'>a = np.array([1,2,3],ndmin=2)
</span><span class='line'>print(a)
</span><span class='line'>[[1 2 3]]
</span><span class='line'>a = np.array([1,2,3],ndmin=3)
</span><span class='line'>print(a)
</span><span class='line'>[[[1 2 3]]]</span></code></pre></td></tr></table></div></figure>


<h4>示例 4 dtype 参数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.array([1,2,3],dtype=complex)
</span><span class='line'>print(a)
</span><span class='line'>[1.+0.j 2.+0.j 3.+0.j]
</span><span class='line'>a = np.array([1,2,3],dtype=int)
</span><span class='line'>print(a)
</span><span class='line'>[1 2 3]
</span><span class='line'>a = np.array([1,2,3],dtype=str)
</span><span class='line'> print(a)
</span><span class='line'>['1' '2' '3']
</span><span class='line'>a = np.array([1,2,3],dtype=bool)
</span><span class='line'>print(a)
</span><span class='line'>[ True  True  True]</span></code></pre></td></tr></table></div></figure>


<h2>ndarray 对象由计算机内存中的一维连续区域组成，带有将每个元素映射到内存块中某个位置的索引方案。 内存块以按行(C 风格)或按列(FORTRAN 或 MatLab 风格)的方式保存元素。</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python_numpy介绍与安装]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy1/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy1</id>
    <content type="html"><![CDATA[<h1>NumPy</h1>

<hr />

<h2>NumPy - 简介</h2>

<h4>NumPy 是一个 Python 包。 它代表 “Numeric Python”。 它是一个由<code>多维数组对象和用于处理数组的例程集合组成的库</code>。</h4>

<hr />

<h2>NumPy 操作</h2>

<h4>使用NumPy，开发人员可以执行以下操作：</h4>

<ul>
<li><p>数组的算数和逻辑运算。</p></li>
<li><p>傅立叶变换和用于图形操作的例程。</p></li>
<li><p>与线性代数有关的操作。 NumPy 拥有线性代数和随机数生成的内置函数。</p></li>
</ul>


<hr />

<h2>NumPy环境安装配置</h2>

<h4>NumPy - 环境</h4>

<h4>启用 NumPy 的最佳方法是使用特定于您的操作系统的可安装的二进制包。 这些二进制包含完整的 SciPy 技术栈(包括 NumPy，SciPy，matplotlib，IPython，SymPy 以及 Python 核心自带的其它包)。</h4>

<h5>window安装</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip install numpy</span></code></pre></td></tr></table></div></figure>


<h5>linux 安装</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install python-numpy </span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试总结2]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_mianshi2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_mianshi2</id>
    <content type="html"><![CDATA[<h1>面试总结2</h1>

<hr />

<h5>内存泄漏和内存溢出的区别和联系</h5>

<h5>1、内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</h5>

<h5>2、内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</h5>

<h5>3、二者关系：</h5>

<ol>
<li>内存泄漏的堆积最终会导致内存溢出</li>
<li>内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。</li>
<li>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。</li>
<li>内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错，

<h5>4、内存泄漏的分类（按发生方式来分类）</h5></li>
<li>常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。</li>
<li>偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。</li>
<li>一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。</li>
<li>隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。</li>
</ol>


<h5>5、内存溢出的原因及解决方法：</h5>

<h5>内存溢出原因：</h5>

<ol>
<li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</li>
<li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；</li>
<li>代码中存在死循环或循环产生过多重复的对象实体；</li>
<li>使用的第三方软件中的BUG；</li>
<li>启动参数内存值设定的过小

<h5>内存溢出的解决方案：</h5>

<h5>第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</h5></li>
</ol>


<h5>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。</h5>

<h5>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。</h5>

<h4>重点排查以下几点：</h4>

<ol>
<li><p>检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</p></li>
<li><p>检查代码中是否有死循环或递归调用。</p></li>
<li><p>检查是否有大循环重复产生新对象实体。</p></li>
<li><p>检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</p></li>
</ol>


<h2><code>使用内存查看工具动态查看内存使用情况</code></h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试总结]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_mianshi1/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_mianshi1</id>
    <content type="html"><![CDATA[<h1>面试总结</h1>

<hr />

<h5>1.list删除中pop、remove、del有什么区别？</h5>

<h5>pop是索引删除，不写参数默认是删除最后一个，返回值是删除的索引对应的值</h5>

<h5>remove是值删除，匹配的第一个匹配的值删除，没有返回值</h5>

<h5>del按照索引删除字符，返回值不可以付给其他的变量。</h5>

<h5>del list1 和list.clear()?</h5>

<hr />

<h5>2.map运行机制？</h5>

<h5>map()函数接受两个参数一个是函数，函数具有一个参数。一个是Iterable</h5>

<h5>map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</h5>

<h5>Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</h5>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP详解]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_linux3/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_linux3</id>
    <content type="html"><![CDATA[<h1>TCP协议详解</h1>

<hr />

<h3>1.   传输层概述</h3>

<ul>
<li><p>TCP服务特点:面向连接、字节流、可靠传输</p>

<h5>TCP面向连接是什么意思？双方在同时使用TCP协议通信，必须先建立连接，然后才开始数据的读写，双发必须为这次连接分配必要的内核资源，以管理连接的状态和数据的传输，同时TCP协议模式是：全双工的，双方的多次读写可以使用一次连接进行，交换数据后双方必须断开连接，释放系统资源，TCP协议针对的是一对一的，基于广播，多播的应用，不能使用TCP，而使用UDP</h5></li>
<li><p>TCP头部信息</p></li>
</ul>


<hr />

<h3>2.   TCP状态转移详解</h3>

<hr />

<h3>3.   TCP简历简介和关闭连接的过程</h3>

<hr />

<h3>4.   RST复位报文段</h3>

<hr />

<h3>5.   TCP可靠性传输机制</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP/IP协议族概述]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_linux2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_linux2</id>
    <content type="html"><![CDATA[<h1>TCP/IP</h1>

<hr />

<h2>TCP/IP协议的体系结构</h2>

<ol>
<li><p>TCP/IP协议族四层模型和OSI七层模型</p>

<h5>OSI七层模型，物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</h5>

<h5>TCP/IP协议四层模型，链路层、网络层、传输层、应用层</h5>

<p><img src="http://shangyajun6943.github.io/images/tcp_6.png" alt="image" /></p></li>
<li><p>四层模型中层次的作用和特点</p>

<h5>链路层：物理连接与传输(不同的类型？以太网，令牌)</h5>

<h5>网络层：数据包的选路与转发（IP层，数据包的选路和转发）</h5>

<h5>传输层：为两台机器提供了端到端的通信，关心传输的起始端和目标端，不在乎中专过程，主要完成数据分发，数据重传的任务</h5>

<p><img src="http://shangyajun6943.github.io/images/tcp_7.png" alt="image" /></p></li>
<li><p>四层模型中层次中对应的协议</p>

<h5>链路层协议：1.ARP协议地址解析协议。2.RARP协议逆地址解析协议。已上两个实现了IP地址和物理地址的转换。</h5></li>
</ol>


<h5>网络层协议（必须把IP地址转化成物理地址才能使用链路层的服务）：1：IP协议：根据数据包的目的IP地址决定如何投递数据包，如果数据包不能直接发送给目标主机，IP协议会为数据包寻找合适的路由器，并把数据包给了路由器进行转发，一直重复，直到到大目的端或发送失败对齐数据包</h5>

<h5>2.ICMP协议：intel网控制报文协议，IP协议的重要补充，主要用于网络连接</h5>

<h5>3.IGMP</h5>

<h5>传输层协议：1.TCP协议，传中控制协议，它为应用层提供的可靠的、面向连接的、面向流的服务</h5>

<h5>2.UDP协议：为应用层提供不可靠的（无法保证正确的从发送端发送到目标端）、无连接的（不保持长久链接）、数据包（有长度，一次性读出）服务</h5>

<h5>3.SCTP协议：流控制传输协议，新的传输协议，控制intel网上电话信号设计的</h5>

<h5>应用层协议：1.telnet协议：远程登录协议</h5>

<h5>2.OSPF协议：开放路径最短优先协议，路由器更新协议，主要路由器之间的通信来告知对方各自的路由信息</h5>

<h5>3.DNS协议：提供机器域名到IP地址转换</h5>

<h5>ping</h5>

<hr />

<h2>数据的封装和分用</h2>

<ol>
<li>数据的封装形式</li>
</ol>


<p><img src="http://shangyajun6943.github.io/images/tcp_1.png" alt="image" /></p>

<ol>
<li>TCP报文段的传输过程</li>
</ol>


<p><img src="http://shangyajun6943.github.io/images/tcp_2.png" alt="image" /></p>

<ol>
<li>最大传送单元（MTU

<h5>在数据链路层传输的数据包称为帧，帧的最大单位称为MTU（Max Transmit Unit），以太网1500K，令牌1492K，超过最大单位就分片</h5></li>
<li>以太网帧格式</li>
</ol>


<p><img src="http://shangyajun6943.github.io/images/tcp_3.png" alt="image" /></p>

<ol>
<li>数据分用的过程</li>
</ol>


<p><img src="http://shangyajun6943.github.io/images/tcp_4.png" alt="image" /></p>

<h5>1.以太网帧在复杂的网络中如何选路？</h5>

<h5>2.网络协议怎么确保传输的数据准确无误的传输？</h5>

<hr />

<h2>ARP协议的工作原理</h2>

<ol>
<li>ARP的用途

<h5>1.ARP协议是地址解析协议</h5>

<h5>2.ARP协议作用：能实现网络地址到任意物理地址的转换</h5>

<h5>3.ARP工作原理：首先主机在自己所在的网络广播一个ARP请求，改请求包含目标机器的网络地址，同时网络上的其他机器都收到这个请求，但是只有被请求的目标机器回应一个ARP应答,其中包含了自己的物理地址</h5></li>
<li>ARP请求/应答报文详解</li>
</ol>


<p><img src="http://shangyajun6943.github.io/images/tcp_5.png" alt="image" /></p>

<h2>3. ARP通信过程</h2>

<h2>DNS协议工作原理</h2>

<ol>
<li>DNS的用途和工作原理

<h5>DNS的作用：将机器的域名转换成IP地址（有很多方法转换，不至DNS一种）</h5>

<h5>DNS的工作原理：我们应用程序发送网址之前（使用的是TCP协议），必须将域名请求DNS服务器（端口53）找到域名对应的IP，才能使用TCP服务进行网络请求。DNS服务器就是一个分布式的IP存储系统。</h5></li>
<li>DNS查询和应答报文详解</li>
<li>Linux访问DNS服务</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux介绍]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_linux1/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_linux1</id>
    <content type="html"><![CDATA[<h1>Linux</h1>

<hr />

<h2>1.什么是Linux</h2>

<h5>1.关于Unux</h5>

<h5>2.什么是GNU和GPL</h5>

<h5>3.Linux起源</h5>

<hr />

<h2>2.Linux版本</h2>

<h5>1.Ubuntu，2004年9月发布，最为流行的<code>桌面</code>的Linux发行版。(个人)</h5>

<h5>2.RedHat,使用最广，性能稳定</h5>

<h5>3.CenOS，2003年底推出，rhel的重新编译版，免费（RedHat克隆出来的）服务器发行版</h5>

<hr />

<h2>Linux优缺点</h2>

<h5>优点</h5>

<ul>
<li>性能稳定()</li>
<li>较高的安全性和Bug的快速修复</li>
<li>支持多用户多任务</li>
<li>完善的用户和群组策略</li>
<li>资源好没底</li>
<li>适合嵌入式应用</li>
<li>免费或费用低廉

<h5>缺点</h5></li>
<li>专业软件支持不够</li>
<li>厂商的支持度不够</li>
<li>标准化不足</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP与HTTPS的区别]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_https/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_https</id>
    <content type="html"><![CDATA[<h5>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</h5>

<h5>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</h5>

<hr />

<h2>一、HTTP和HTTPS的基本概念</h2>

<ul>
<li>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</li>
<li>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</li>
<li>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</li>
</ul>


<hr />

<h2>二、HTTP与HTTPS有什么区别？</h2>

<h5>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</h5>

<h3>HTTPS和HTTP的区别主要如下：</h3>

<ul>
<li><p>1.https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p></li>
<li><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p></li>
<li><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p></li>
<li><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p></li>
</ul>


<hr />

<h2>三、HTTPS的工作原理</h2>

<h5>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示</h5>

<ul>
<li>（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</li>
<li>（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</li>
<li>（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li>
<li>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li>
<li>（5）Web服务器利用自己的私钥解密出会话密钥。</li>
<li>（6）Web服务器利用会话密钥加密与客户端之间的通信。
<img src="https://pic002.cnblogs.com/images/2012/339704/2012071410212142.gif" alt="image" /></li>
</ul>


<hr />

<h2>四、HTTPS的优点</h2>

<h5>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</h5>

<ul>
<li><p>（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li>
<li><p>（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p></li>
<li><p>（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p></li>
<li><p>（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p></li>
</ul>


<hr />

<h2>五、HTTPS的缺点</h2>

<h5>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</h5>

<ul>
<li><p>（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p></li>
<li><p>（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p></li>
<li><p>（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p></li>
<li><p>（4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p></li>
<li><p>（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行</p></li>
</ul>


<hr />

<h2>六、http切换到HTTPS</h2>

<h5>如果需要将网站从http切换到https到底该如何实现呢？</h5>

<h5>这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：<a href="http://www.baidu.com%E6%94%B9%E4%B8%BAhttps://www.baidu.comBTW%EF%BC%8C%E8%BF%99%E9%87%8C%E8%99%BD%E7%84%B6%E5%B0%86http%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%86https%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BB%BA%E8%AE%AE%E4%BF%9D%E7%95%99http%E3%80%82%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E5%9C%A8%E5%88%87%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E5%81%9Ahttp%E5%92%8Chttps%E7%9A%84%E5%85%BC%E5%AE%B9%EF%BC%8C%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%98%AF%EF%BC%8C%E5%8E%BB%E6%8E%89%E9%A1%B5%E9%9D%A2%E9%93%BE%E6%8E%A5%E4%B8%AD%E7%9A%84http%E5%A4%B4%E9%83%A8%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%8C%B9%E9%85%8Dhttp%E5%A4%B4%E5%92%8Chttps%E5%A4%B4%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%9A%E5%B0%86http://www.baidu.com%E6%94%B9%E4%B8%BA//www.baidu.com%E3%80%82%E7%84%B6%E5%90%8E%E5%BD%93%E7%94%A8%E6%88%B7%E4%BB%8Ehttp%E7%9A%84%E5%85%A5%E5%8F%A3%E8%BF%9B%E5%85%A5%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%B0%B1%E6%98%AFhttp%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8%E6%88%B7%E6%98%AF%E4%BB%8Ehttps%E7%9A%84%E5%85%A5%E5%8F%A3%E8%BF%9B%E5%85%A5%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%8D%B3%E4%BD%BFhttps%E7%9A%84%E3%80%82">http://www.baidu.com%E6%94%B9%E4%B8%BAhttps://www.baidu.comBTW%EF%BC%8C%E8%BF%99%E9%87%8C%E8%99%BD%E7%84%B6%E5%B0%86http%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%86https%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BB%BA%E8%AE%AE%E4%BF%9D%E7%95%99http%E3%80%82%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E5%9C%A8%E5%88%87%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E5%81%9Ahttp%E5%92%8Chttps%E7%9A%84%E5%85%BC%E5%AE%B9%EF%BC%8C%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%98%AF%EF%BC%8C%E5%8E%BB%E6%8E%89%E9%A1%B5%E9%9D%A2%E9%93%BE%E6%8E%A5%E4%B8%AD%E7%9A%84http%E5%A4%B4%E9%83%A8%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%8C%B9%E9%85%8Dhttp%E5%A4%B4%E5%92%8Chttps%E5%A4%B4%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%9A%E5%B0%86http://www.baidu.com%E6%94%B9%E4%B8%BA//www.baidu.com%E3%80%82%E7%84%B6%E5%90%8E%E5%BD%93%E7%94%A8%E6%88%B7%E4%BB%8Ehttp%E7%9A%84%E5%85%A5%E5%8F%A3%E8%BF%9B%E5%85%A5%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E6%97%B6%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%B0%B1%E6%98%AFhttp%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8%E6%88%B7%E6%98%AF%E4%BB%8Ehttps%E7%9A%84%E5%85%A5%E5%8F%A3%E8%BF%9B%E5%85%A5%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%8D%B3%E4%BD%BFhttps%E7%9A%84%E3%80%82</a></h5>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git安装-简单配置]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_git2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_git2</id>
    <content type="html"><![CDATA[<h1>git安装-简单配置</h1>

<hr />

<ol>
<li>git的安装—git-scm.com</li>
<li>git的自动完成 在windows系统下默认就是自动补全的</li>
<li>git的自动完成 在linux系统下</li>
</ol>


<h5>在git源码包(如果没有去github上下载git<a href="https://github.com/git/git">源码地址</a>)的./contrib/completion目录下有两个文件</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git-completion.bash
</span><span class='line'>git-prompt.sh</span></code></pre></td></tr></table></div></figure>


<h5>其中git-completion.bash是自动补全脚本,git-prompt.sh是状态提示脚本.</h5>

<h5>把他们两个放到/etc/profile.d/目录下,再把git-completion.bash改名为 gitcompletion.sh 然后创建一个git.sh文件(或者直接修改在/etc/profile文件)在里面加入以下内容</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export GIT_PS1_SHOWDIRTYSTATE=1
</span><span class='line'>export GIT_PS1_SHOWSTASHSTATE=1
</span><span class='line'>export GIT_PS1_SHOWUNTRACKEDFILES=1
</span><span class='line'>export GIT_PS1_SHOWUPSTREAM="verbose git svn"
</span><span class='line'>PS1='\[\033[1;32m\]\u@\h \[\033[1;34m\]\W\[\033[1;31m\]$(__git_ps1 " (%s)")\[\033[1;35m\] $ \[\033[0m\]'</span></code></pre></td></tr></table></div></figure>


<h5>重启后</h5>

<h4>git version-1.9.1以上的似乎已经默认加上了git的自动补全的功能。所以无需自己配置：原因就在下面的脚本里面吧：</h4>

<h4>可以看见有这个脚本文件:/usr/lib/git-core/git-sh-prompt也就是git自动补全脚本</h4>

<h4>它是被/etc/bash_completion.d/ 下的git-prompt脚本所包含的</h4>

<h4>这里提供手动设置git自动补全功能：</h4>

<ol>
<li><p><a href="https://github.com/markgandolfo/git-bash-completion.git%E4%B8%8A%E4%B8%8B%E8%BD%BD%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E8%84%9A%E6%9C%AC">https://github.com/markgandolfo/git-bash-completion.git%E4%B8%8A%E4%B8%8B%E8%BD%BD%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E8%84%9A%E6%9C%AC</a>(git-bash-completion)</p></li>
<li><p>复制脚本文件git-bash-completion至目录/etc/bash_completion.d/下</p></li>
<li></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$cp git-completion.bash  /etc/bash_completion.d/</span></code></pre></td></tr></table></div></figure>


<h4>或者直接一步到位：1-2步</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo wget --no-check-certificate -P /etc/bash_completion.d/ https://raw.githubusercontent.com/markgandolfo/git-bash-completion/master/git-completion.bash</span></code></pre></td></tr></table></div></figure>


<ol>
<li>使脚本生效：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./etc/bash_completion.d/git-completion.bash</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>git简单配置</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config --global user.name ShangYaJun
</span><span class='line'>git config --global user.email 373296201@qq.com</span></code></pre></td></tr></table></div></figure>


<h5>这是git中最基本的配置，提交的时候用到，告诉每次提交的时候，提交的文件作者是谁？文件修改之后提交的作者是谁？</h5>

<h5>还可以这样添加作者</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config --global user.name --add ***</span></code></pre></td></tr></table></div></figure>


<h5>还可以这样删除作者</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config --global --unset user.name ***</span></code></pre></td></tr></table></div></figure>


<h5>还可以这样修改作者</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>```
</span><span class='line'>#####查看所有用户信息</span></code></pre></td></tr></table></div></figure>


<p>git config &ndash;get user.name</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>```
</span><span class='line'>git config --get user.email</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config --list --global</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>git配置的三个级别</h3>

<ol>
<li>git config &ndash;local   针对当前的仓库，优先级最高</li>
<li>git config –global  针对当前用户，优先级中</li>
<li>git config –system</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config –list  查看所有的配置信息</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config –global –list 查看针对用户的配置信息</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config –local –list 查看单签仓库的配置信息</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config –add 添加仓库的配置信息或git config –local –add</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config –global –add 添加当前用户的配置信息</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config –global –get 的到当前用户的某个信息</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config –local –unset</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config –local –unset-all 不设置（删除）仓库的某个配置信息</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config –global user.name *** 第一次是添加（第二次就是修改名字）</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>为git子命令配置别名</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git config --global alias.ck checkout 给checkout七个别名</span></code></pre></td></tr></table></div></figure>


<h5>使用</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git ck</span></code></pre></td></tr></table></div></figure>


<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git简介]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_git/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_git</id>
    <content type="html"><![CDATA[<h1>git简介</h1>

<hr />

<h3>1.git历史</h3>

<h4>Git是一款代码管理工具（Version Control System)，无疑对比现在市面上的VCS，“Git”绝对是最牛逼的。深层次的讲，在公司的时候，某大神曾讲：“Git的出现，使得其他国家和美国的计算机水平差距拉近了30年！！！”，也是从那个时候起，小生励志要好好学习Git，造福网友。</h4>

<h4>这段历史，我在网上的资料中看的也是如痴如醉，首先Git的创始人是“Linus Torvalds”，如果你不知道他是何许人也，我想也就没有必要再贵圈混下去了，爆照：（帅锅程序猿一枚）</h4>

<p><img src="http://shangyajun6943.github.io/images/git/git5.png" alt="image" /></p>

<h4>如图，是Linus年轻时候的照片，没错，这就是Linux的创始人， 网上有很多“Git十年访谈”的访谈帖子，放个链接（<a href="http://geek.csdn.net/news/detail/30067%EF%BC%89%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%9C%8B%E5%8F%8B%E5%8F%AF%E4%BB%A5%E5%8E%BB%E6%90%9C%E6%90%9C%E7%9C%8B%E3%80%82">http://geek.csdn.net/news/detail/30067%EF%BC%89%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%9C%8B%E5%8F%8B%E5%8F%AF%E4%BB%A5%E5%8E%BB%E6%90%9C%E6%90%9C%E7%9C%8B%E3%80%82</a></h4>

<h4>言归正传，起初参与Linux开源项目的代码是由Linus本人通过“diff”和“patch”命令来手动为别人整合代码的，之后正如在《Pro Git》这本书中所讲到的，随着项目越做越大，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。直到2005年，Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！Git也由此诞生了。然而牛逼的人生从来不需要解释这句话被Linus展现的淋漓尽致……</h4>

<h4>就这样子，又10年过去了，Git越来越成熟，小生在北京工作的时候第一次安装Git Extention和Git Bash的时候，就被其强大的功能所折服了，Git绝对不是一个简单的工具，是开源精神的产物，人类进步的见证！！！</h4>

<hr />

<h3>2.git与svn的对比</h3>

<h4>SVN集中式版本控制</h4>

<p><img src="http://shangyajun6943.github.io/images/git/git1.png" alt="image" /></p>

<h5>如上图所示，是集中式版本控制的原理图。比较流行的工具有CVS，Subversion(SVN)以及Perferce等，他们都有一个单一的几种管理的服务器，保存所有文件的修订版本，协同工作的人（如图中的Computer A、Computer B）通过客户端连接到Central VCS Server这台服务器上，取出或者提交文件，而这也成为了版本控制系统的标准做法。</h5>

<h5>相比老式的VCS，每个人能看到项目中其他人在干嘛，管理员也可以控制每个开发者的权限，但是一个致命的缺点就是中央服务器的单点故障。如果发生，谁都无法提交更新，无法协同工作，甚至有丢失数据的风险。至此，后来产生了“分布式版本控制工具”。</h5>

<h4>git分布式版本控制</h4>

<p><img src="http://shangyajun6943.github.io/images/git/git2.png" alt="image" /></p>

<h5>如图，是分布式版本控制的示意图，比较火的有Git，Bazaar等，原理在于：“客户端并不是提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来”，这样一来，任何一处协同工作的服务器发生故障，事后可以使用任何一个镜像出来的本地仓库恢复，因为每一次提取操作，都是对镜像的完整备份。</h5>

<h5>由此便对版本控制的历史进行了回顾，对于“分布式版本控制”中的Git，除了有上述的有点之外，还有相对于其他“分布式版本控制”的独特之处，后边给予分析，至此，VCS的宏观概念就建立了。</h5>

<h3>Svn与git的另一个区别？版本存储差异！</h3>

<h5>SVN如图：每次版本的存储，只是存储版本之间的差异。如果想要过去版本2的代办，只有从版本1中查找与版本2之间的差异，再合成代码</h5>

<p><img src="http://shangyajun6943.github.io/images/git/git3.png" alt="image" /></p>

<h5>Git如图：每次的版本的存储都是存储的每次版本的代码，而不是差异，所以想要获取每次版本的代码，直接获取即可。</h5>

<p><img src="http://shangyajun6943.github.io/images/git/git4.png" alt="image" /></p>

<hr />

<h3>3.为什么要使用git？</h3>

<ol>
<li>git的是分布式的，SVN是集中式的</li>
<li>git存储的历史版本是完整的，SVN是存储之间的差异</li>
<li>git可离线完成大部分工作，SVN只能在线完成</li>
<li>git有更优雅的分支和合并的实现</li>
<li>git有更强的撤销修改和修改版本历史的能力</li>
<li>git速度更快、效率更高</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Empty]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_empty/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_empty</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态规划—字符串解码]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_dp_str/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_dp_str</id>
    <content type="html"><![CDATA[<h1>字符串解码</h1>

<h2>一个包含字母的消息被加密后变成一个只包含数字的字符串，但是我们知道加密的规则：</h2>

<h2>&lsquo;A&rsquo;->1</h2>

<h2>&lsquo;B&rsquo;->2</h2>

<h2>..</h2>

<h2>&lsquo;Z&rsquo;->26</h2>

<h2>问：随机给个字符串‘12345671215646’有几种解密的方式？</h2>

<h2>例：‘12’->&lsquo;AB&rsquo; or &lsquo;12&rsquo;->L</h2>

<hr />

<hr />

<hr />

<hr />

<hr />
]]></content>
  </entry>
  
</feed>
