<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[夕阳还是很红]]></title>
  <link href="http://shangyajun6943.github.io/atom.xml" rel="self"/>
  <link href="http://shangyajun6943.github.io/"/>
  <updated>2018-08-27T23:03:54+08:00</updated>
  <id>http://shangyajun6943.github.io/</id>
  <author>
    <name><![CDATA[尚亚军]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Docker容器]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/08/12/shangyajunblog_docker_2/"/>
    <updated>2018-08-12T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/08/12/shangyajunblog_docker_2</id>
    <content type="html"><![CDATA[<h1>Docker容器</h1>

<hr />

<h2>1. 容器的基本操作</h2>

<h4>启动容器docker</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>run [OPTIONS] IMAGE [COMMAND] [ARG...]</span></code></pre></td></tr></table></div></figure>


<h4>一次启动运行一次的容器，是docker中最基本的命令，运行完就结束</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run ubuntu echo 'hello world!'</span></code></pre></td></tr></table></div></figure>


<h4>启动交互式容器：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -i-t IMAGE /bin/bash
</span><span class='line'>-i 为容器提供标准的输入
</span><span class='line'>-t 为容器提供一个tty终端</span></code></pre></td></tr></table></div></figure>


<h4>查看我们创建的容器，和以前使用过的容器</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker ps [-a][-l]
</span><span class='line'>-a  -all 列出所有的容器
</span><span class='line'>-l  列出最新创建的容器
</span><span class='line'>
</span><span class='line'>sudo docker inspect [name|id] 可以查看指定docker的配置信息</span></code></pre></td></tr></table></div></figure>


<h4>创建自己名称docker容器</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run --name=[name] ubuntu echo 'hello world!'</span></code></pre></td></tr></table></div></figure>


<h4>重新启动停止的容器：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker start [-i] 容器名
</span><span class='line'>-i 表示重新启动停止的容器</span></code></pre></td></tr></table></div></figure>


<h4>删除不需要的容器(删除停止的容器，不能删除运行中的容器)</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker rm 容器名</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>2. 守护式容器</h2>

<h4>什么是守护式容器？在我们一开始创建了容器后，都是执行完命令后就容器停止了运行。但是守护式容器，不一样！！！！</h4>

<ol>
<li>能够长期运行</li>
<li>没有交互式会话</li>
<li>适合运行应用程序和服务</li>
</ol>


<h4>如何运行守护式容器呢？</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -i -t ubuntu /bin/bash
</span><span class='line'>使用ctrl+q或ctrl+p退出容器后，容器就会在后台运行</span></code></pre></td></tr></table></div></figure>


<h4>那么怎么再次进入运行在后台的容器呢？</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker attach [容器名]</span></code></pre></td></tr></table></div></figure>


<h4>启动守护式容器：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker run -d IMAGE [COMMAND] [ARG...]</span></code></pre></td></tr></table></div></figure>


<h4>查看容器的日志</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker logs [-f] [-t] [--tail] 容器名
</span><span class='line'>-f --follows=true|false 默认false 跟踪：一直更新日志
</span><span class='line'>-t --timestamps=true|false 默认false 显示时间戳
</span><span class='line'>--tail='all' 只显示最新的</span></code></pre></td></tr></table></div></figure>


<h4>查看容器中的进程</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker top 容器名</span></code></pre></td></tr></table></div></figure>


<h4>在运行中的容器中启动新的进程</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo docker exec [-d][-i][-t] 容器名[COMMAND] [ARG...]
</span><span class='line'>sudo docker exec -i -d 容器名 /bin/bash</span></code></pre></td></tr></table></div></figure>


<h4>停止守护式容器</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>docker stop 容器名  发送一个停止的信号给容器，等待容器停止
</span><span class='line'>docker kill 容器名  直接停止容器，不用等待</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>3. 在容器中部署静态网站</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker安装]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/08/12/shangyajunblog_docker_1/"/>
    <updated>2018-08-12T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/08/12/shangyajunblog_docker_1</id>
    <content type="html"><![CDATA[<h1>Docker安装</h1>

<hr />

<h2>1. 私有环境安装docker</h2>

<hr />

<h2>2. 公有环境安装docker</h2>

<h4>安装前的检查：</h4>

<h5>1.内核的检查</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>uname -a</span></code></pre></td></tr></table></div></figure>


<h5>2.检查Device Mapper的检查</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ls -l /sys/class/misc/device-mapper</span></code></pre></td></tr></table></div></figure>


<h4>安装docker维护的版本</h4>

<h5>1.检查APT的HTTPS支持查看文件是否存在</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/usr/lib/apt/methods/https</span></code></pre></td></tr></table></div></figure>


<h5>不存在：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>apt-get update
</span><span class='line'>pat-get install -y apt-transport-https</span></code></pre></td></tr></table></div></figure>


<h5>2.添加Docker的APT仓库</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo deb https://getdocker.com/ubuntu docker main &gt; /etc/apt/sources.list.d/docker.list</span></code></pre></td></tr></table></div></figure>


<h5>3. 添加仓库的key</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys </span></code></pre></td></tr></table></div></figure>


<h5>4. 安装</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>apt-get update
</span><span class='line'>apt-get install -y lxc-docker</span></code></pre></td></tr></table></div></figure>


<h2>安装简易的命令：</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get update
</span><span class='line'>sudo apt-get install \
</span><span class='line'>    apt-transport-https \
</span><span class='line'>    ca-certificates \
</span><span class='line'>    curl \
</span><span class='line'>    software-properties-common
</span><span class='line'>curl -fsSL https://get.docker.com -o get-docker.sh
</span><span class='line'>sudo sh get-docker.sh</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>3. 配置国内镜像仓库</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django-Django全文搜索]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_quanwen_2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_quanwen_2</id>
    <content type="html"><![CDATA[<h1>Django-Django全文搜索haystack</h1>

<h4>haystack官网：<a href="http://django-haystack.readthedocs.io/en/master/">http://django-haystack.readthedocs.io/en/master/</a></h4>

<h1>使用的工具</h1>

<ul>
<li>haystack是django的开源搜索框架，该框架支持Solr, Elasticsearch, Whoosh, Xapian搜索引擎，不用更改代码，直接切换引擎，减少代码量。</li>
<li>搜索引擎使用Whoosh，这是一个由纯Python实现的全文搜索引擎，没有二进制文件等，比较小巧，配置比较简单，当然性能自然略低。</li>
<li>中文分词Jieba，由于Whoosh自带的是英文分词，对中文的分词支持不是太好，故用jieba替换whoosh的分词组件。

<h1>配置说明</h1>

<h6>现在假设我们的项目叫做Project,有一个myapp的app，简略的目录结构如下。</h6>

<h3>此models.py的内容假设如下：</h3></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from django.db import models
</span><span class='line'>from django.contrib.auth.models import User
</span><span class='line'>class Note(models.Model):
</span><span class='line'>    user = models.ForeignKey(User)
</span><span class='line'>    pub_date = models.DateTimeField()
</span><span class='line'>    title = models.CharField(max_length=200)
</span><span class='line'>    body = models.TextField()
</span><span class='line'>    def __str__(self):
</span><span class='line'>        return self.title</span></code></pre></td></tr></table></div></figure>


<h2>1.首先安装各工具</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip install whoosh django-haystack jieba</span></code></pre></td></tr></table></div></figure>


<h2>2.添加 Haystack 到Django的 INSTALLED_APPS</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>INSTALLED_APPS = [ 
</span><span class='line'>        'django.contrib.admin',
</span><span class='line'>        'django.contrib.auth', 
</span><span class='line'>        'django.contrib.contenttypes', 
</span><span class='line'>        'django.contrib.sessions', 
</span><span class='line'>        'django.contrib.sites',
</span><span class='line'>          # Added. haystack先添加，
</span><span class='line'>          'haystack', 
</span><span class='line'>          # Then your usual apps... 自己的app要写在haystakc后面
</span><span class='line'>          'blog',
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>


<h2>3.修改 你的 settings.py，以配置引擎</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HAYSTACK_CONNECTIONS = {
</span><span class='line'>    'default': {
</span><span class='line'>        'ENGINE': 'haystack.backends.whoosh_backend.WhooshEngine',
</span><span class='line'>        'PATH': os.path.join(os.path.dirname(__file__), 'whoosh_index'),
</span><span class='line'>    },
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h6>其中顾名思义，ENGINE为使用的引擎必须要有，如果引擎是Whoosh，则PATH必须要填写，其为Whoosh 索引文件的存放文件夹。其他引擎的配置见官方文档<a href="http://django-haystack.readthedocs.io/en/master/">http://django-haystack.readthedocs.io/en/master/</a></h6>

<h2>4.创建索引</h2>

<h6>如果你想针对某个app例如mainapp做全文检索，则必须在mainapp的目录下面建立search_indexes.py文件，文件名不能修改。内容如下：</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import datetime
</span><span class='line'>from haystack import indexes
</span><span class='line'>from myapp.models import Note
</span><span class='line'>class NoteIndex(indexes.SearchIndex, indexes.Indexable):
</span><span class='line'>    text = indexes.CharField(document=True, use_template=True)
</span><span class='line'>    author = indexes.CharField(model_attr='user')
</span><span class='line'>    pub_date = indexes.DateTimeField(model_attr='pub_date')
</span><span class='line'>    def get_model(self):
</span><span class='line'>        return Note
</span><span class='line'>    def index_queryset(self, using=None):
</span><span class='line'>        """Used when the entire index for model is updated."""
</span><span class='line'>        return self.get_model().objects.filter(pub_date__lte=datetime.datetime.now())</span></code></pre></td></tr></table></div></figure>


<h6>每个索引里面必须有且只能有一个字段为document=True，这代表haystack 和搜索引擎将使用此字段的内容作为索引进行检索(primary field)。其他的字段只是附属的属性，方便调用，并不作为检索数据。</h6>

<h6>注意：如果使用一个字段设置了document=True，则一般约定此字段名为text，这是在SearchIndex类里面一贯的命名，以防止后台混乱，当然名字你也可以随便改，不过不建议改。</h6>

<h6>并且，haystack提供了use_template=True在text字段，这样就允许我们使用数据模板去建立搜索引擎索引的文件，使用方便（官方推荐，当然还有其他复杂的建立索引文件的方式，目前我还不知道），数据模板的路径为yourapp/templates/search/indexes/yourapp/note_text.txt，例如本例子为blog/templates/search/indexes/blog/note_text.txt文件名必须为要索引的类名_text.txt,其内容为</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\{\{ object.title \}\}\{\{ object.user.get_full_name \}\}
</span><span class='line'>  \{\{ object.body \}\}</span></code></pre></td></tr></table></div></figure>


<h6>这个数据模板的作用是对Note.title, Note.user.get_full_name,Note.body这三个字段建立索引，当检索的时候会对这三个字段做全文检索匹配。</h6>

<h3>在urls.py中配置如下url信息，当然url路由可以随意写。</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(r'^search/', include('haystack.urls')),</span></code></pre></td></tr></table></div></figure>


<h6>其实haystack.urls的内容为，</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from django.conf.urls import url
</span><span class='line'>from haystack.views import SearchView
</span><span class='line'>urlpatterns = [
</span><span class='line'>    url(r'^$', SearchView(), name='haystack_search'),
</span><span class='line'>]</span></code></pre></td></tr></table></div></figure>


<h6>SearchView()视图函数默认使用的html模板为当前app目录下，路径为myapp/templates/search/search.html</h6>

<h6>所以需要在blog/templates/search/下添加search.html文件，自带了分页,内容为</h6>

<h6><a href="http://django-haystack.readthedocs.io/en/master/tutorial.html#handling-data">http://django-haystack.readthedocs.io/en/master/tutorial.html#handling-data</a></h6>

<h2>5.重建索引文件</h2>

<h3>使用python manage.py rebuild_index或者使用update_index命令。</h3>

<h2>6. 使用jieba分词</h2>

<h6># 1.将文件whoosh_backend.py（该文件路径为python路径/lib/python3.4/site-packages/haystack/backends/whoosh_backend.py）拷贝到app下面，并重命名为whoosh_cn_backend.py，例如blog/whoosh_cn_backend.py。修改如下添加from jieba.analyse import ChineseAnalyzer修改为如下</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>schema_fields[field_class.index_fieldname] =
</span><span class='line'>    TEXT(stored=True, analyzer=ChineseAnalyzer(),
</span><span class='line'>            field_boost=field_class.boost)</span></code></pre></td></tr></table></div></figure>


<h3>2. 在settings.py中修改引擎，如下</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HAYSTACK_CONNECTIONS = {
</span><span class='line'>    'default': {
</span><span class='line'>        'ENGINE': 'blog.whoosh_cn_backend.WhooshEngine',
</span><span class='line'>        'PATH': os.path.join(BASE_DIR, 'whoosh_index'
</span><span class='line'>    },
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>3.重建索引，在进行搜索中文试试吧。</h3>

<h1>索引自动更新</h1>

<h6>如果没有索引自动更新，那么每当有新数据添加到数据库，就要手动执行update_index命令是不科学的。自动更新索引的最简单方法在settings.py添加一个信号。</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HAYSTACK_SIGNAL_PROCESSOR =
</span><span class='line'>            "haystack.signals.RealtimeSignalProcesso"</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django-全文检索]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_quanwen_1/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_quanwen_1</id>
    <content type="html"><![CDATA[<h1>Django-全文检索概念</h1>

<p>-概念</p>

<h6>全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。全文搜索搜索引擎数据库中的数据。</h6>

<ul>
<li>方法

<h6>主要分为按字检索和按词检索两种。按字检索是指对于文章中的每一个字都建立索引，检索时将词分解为字的组合。按词检索指对文章中的词，即语义单位建立索引，检索时按词检索，并且可以处理同义项等。</h6></li>
</ul>


<p>-搜索引擎分类</p>

<h3>全文搜索、目录搜索、元搜索、垂直搜索</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Os处理器状态]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_os2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_os2</id>
    <content type="html"><![CDATA[<h1>处理器状态</h1>

<hr />

<h4>中央处理器（CPU）</h4>

<h5>处理器组成：运算器、控制器、一系列的<code>寄存器</code>、高速缓存</h5>

<h5>两种寄存器</h5>

<ol>
<li>用户可见寄存器：高级语言编译器通过优化算法分配并使用，以减少程序的访问内存的次数，提高运行效率</li>
<li>控制和状态寄存器：用于控制处理器的操作，通常由操作系统代码使用</li>
</ol>


<hr />

<h4>控制和状态寄存器</h4>

<ul>
<li>用于控制处理器的操作</li>
<li>在某种特权级别下可以访问、修改</li>
<li><p>常见的控制和状态寄存器：</p></li>
<li><p>程序计数器（PC：program Counter）：记录将取出的指令地址</p></li>
<li>指令寄存器（IR：Instruction Register）：记录最近取出的指令</li>
<li>程序状态字（PSW：Program Status Word）：记录处理器的运行状态如：条形码、模式、控制位等信息。</li>
</ul>


<hr />

<h4>现代CPU状态设计划分：两种、三种或四种</h4>

<h5>在程序状态字寄存器PSW中专门是指一位，根据运行程序<code>对资源和指令的使用权限</code>而设置不同的CPU状态</h5>

<h3>操作系统需要两种CPU状态</h3>

<ol>
<li>内核态：运行操作系统程序</li>
<li>用户态：运行用户程序</li>
</ol>


<h4>特权指令：只能有操作系统使用、用户程序不能使用的指令。启动IO、内存清零、修改程序状态字、设置时钟、允许/禁止中断、停机</h4>

<h4>非特权指令：用户程序可以使用的指令</h4>

<h3>X86支持4个处理器特权级别，特权环：R0-R3</h3>

<h4>R0相当于内核态，R3相当于用户态，R1和R2结余两者之间</h4>

<hr />

<h3>CPU状态之间的转换</h3>

<h6>用户态->内核态  唯一途径-> 中断/异常/陷入机制</h6>

<h6>内核态->用户态  设置程序状态字PSW</h6>

<h5>一条特殊的指令：陷入指令（又称访管指令）：提供给用户程序的接口，用于调用操作系统的功能（服务）。如：int、trap、syscall、sysenter/sysexit</h5>

<hr />

<h2>中断/异常机制</h2>

<h4>中断/异常：对于操作系统的重要性就好比：汽车的发动机、飞机的引擎，可以这么说：操作系统是由‘中断驱动’或者‘事件驱动’的</h4>

<h4>中断/异常：CPU对系统发生中的某个事件做出的一种反应，事件的发生改变了处理器的控制流</h4>

<h4>中断/异常：CPU暂停正在执行的程序，保留现场后自动转去执行相应的事件的处理程序，处理完成后返回断点，继续执行被打断的程序。</h4>

<h4>特点：随机发生、自动处理、和恢复</h4>

<h3>为什么引入中断与异常？</h3>

<h2>中断/异常合称：事件</h2>

<h3>事件分为：外中断（中断）、内中断（异常）</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[操作系统]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_os1/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_os1</id>
    <content type="html"><![CDATA[<h1>操作系统怎么执行程序的？</h1>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>include &lt;stdio.h&gt;
</span><span class='line'>int main(int argc,char *argc[])
</span><span class='line'>{
</span><span class='line'>  puts("hello word!");
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>以这个程序为例，解释操作系统怎么调用程序！</h5>

<hr />

<ol>
<li>首先我们告诉操作系统我们执行helloworld程序(使用命令，或双击)</li>
<li>操作系统接受到用户请求，找到helloworld程序的相关信息，检查文件是否是可执行文件；并通过程序的首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。（可执行文件格式：window：pe linux：elf）</li>
<li>操作系统：创建一个进程，并将helloworld可执行文件映射到改进程结构，表示由该进程执行helloworld程序</li>
<li>操作系统：为helloworld程序设置CPU上下文环境并跳到程序开始处（假设调度程序选中了hello程序）</li>
<li>调度程序：执行helloworld程序的第一条指令，发生<code>缺页异常</code>（因为执行文件需要把程序读入内存）</li>
<li>操作系统：分配一页空闲的物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序（有时候程序很大，操作系统会多次从磁盘读程序进入内存，也会发生很多次缺页异常）</li>
<li>helloworld程序执行puts函数（系统调用），在显示器上写一字符串</li>
<li>操作系统：找到要将字符串宋往的显示设备，通常设备是由一个进程控制的，所以操作系统将写的字符串送给该进程</li>
<li>操作系统：控制设备的进程告诉设备的窗口系统它要显示的字符串，窗口系统确定知识一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区。</li>
<li>视频硬件将像素转换成显示器可接收的一组控制/数据信号</li>
<li>显示器解释信号，激发液晶屏</li>
<li>我们在屏幕上看到了‘helloworld’</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress环境的搭建]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_octopress2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_octopress2</id>
    <content type="html"><![CDATA[<h1>octopress环境的搭建</h1>

<h3>git、ruby、Devkit、markdownPad的安装与配置</h3>

<ul>
<li>git：版本管理工具，将代码托管到github上</li>
<li>Ruby+Devkit：生成静态的页面</li>
<li>MarkdwonPad:z在window下Markdown语法编辑器</li>
</ul>


<h2>1.    git安装与配置</h2>

<h2>2.    ruby安装与配置</h2>

<h2>3.    Devkit安装与配置</h2>

<h2>4.    Ruby与Devkit关联</h2>

<h2>5.安装octopress并设置默认主题</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy - NumPy - 高级索引⑧]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy9/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy9</id>
    <content type="html"><![CDATA[<h1>NumPy - 高级索引</h1>

<h4>如果一个ndarray是非元组序列，数据类型为整数或布尔值的ndarray，或者至少一个元素为序列对象的元组，我们就能够用它来索引ndarray。高级索引始终返回数据的副本。 与此相反，切片只提供了一个视图。</h4>

<h4>有两种类型的高级索引：整数和布尔值。</h4>

<hr />

<h3>整数索引</h3>

<h4>这种机制有助于基于 N 维索引来获取数组中任意元素。 每个整数数组表示该维度的下标值。 当索引的元素个数就是目标ndarray的维度时，会变得相当直接。</h4>

<h4>以下示例获取了ndarray对象中每一行指定列的一个元素。 因此，行索引包含所有行号，列索引指定要选择的元素。 也就是矩阵的下表取值。X（i，j）</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import numpy as np
</span><span class='line'>a = np.array([[1,2,3,4],[5,6,7,8],[9,6,4,7]])
</span><span class='line'>a
</span><span class='line'>array([[1, 2, 3, 4],
</span><span class='line'>       [5, 6, 7, 8],
</span><span class='line'>       [9, 6, 4, 7]])
</span><span class='line'>a[[0,0,2,2],[0,3,0,3]]
</span><span class='line'>array([1, 4, 9, 7])
</span><span class='line'>分别取4个角的点(0,0),(0,3),(2,0),(2,3)的元素组成一个数组</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x = np.array([[  0,  1,  2],[  3,  4,  5],[  6,  7,  8],[  9,  10,  11]])
</span><span class='line'>x
</span><span class='line'>array([[ 0,  1,  2],
</span><span class='line'>       [ 3,  4,  5],
</span><span class='line'>       [ 6,  7,  8],
</span><span class='line'>       [ 9, 10, 11]])
</span><span class='line'>rows = np.array([[0,0],[3,3]])
</span><span class='line'>cols = np.array([[0,2],[0,2]])
</span><span class='line'>x[rows,cols]
</span><span class='line'>array([[ 0,  2],
</span><span class='line'>       [ 9, 11]])
</span><span class='line'>分别取4个角的点(0,0),(0,2),(3,0),(3,2)的元素组成一个2维的数组，所以以后我们可以选取任何几个元素组成几维数组，例如：以下</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rows = np.array([[0,0],[2,2]])
</span><span class='line'>cols = np.array([[1,2],[1,2]])
</span><span class='line'>x[rows,cols]
</span><span class='line'>array([[1, 2],
</span><span class='line'>       [7, 8]])</span></code></pre></td></tr></table></div></figure>


<h4>高级和基本索引可以通过使用切片:或省略号&hellip;与索引数组组合。 以下示例使用slice作为列索引和高级索引。 当切片用于两者时，结果是相同的。 但高级索引会导致复制，并且可能有不同的内存布局。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x = np.array([[  0,  1,  2],[  3,  4,  5],[  6,  7,  8],[  9,  10,  11]])  
</span><span class='line'>print  '我们的数组是：'  
</span><span class='line'>print x 
</span><span class='line'>print  '\n'  
</span><span class='line'>切片
</span><span class='line'>z = x[1:4,1:3]  
</span><span class='line'>print  '切片之后，我们的数组变为：'  
</span><span class='line'>print z 
</span><span class='line'>print  '\n'  
</span><span class='line'>对列使用高级索引 
</span><span class='line'>y = x[1:4,[1,2]] 
</span><span class='line'>print  '对列使用高级索引来切片：'  
</span><span class='line'>print y</span></code></pre></td></tr></table></div></figure>


<h4>结果</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>我们的数组是：
</span><span class='line'>[[ 0  1  2] 
</span><span class='line'> [ 3  4  5] 
</span><span class='line'> [ 6  7  8]
</span><span class='line'> [ 9 10 11]]
</span><span class='line'>切片之后，我们的数组变为：
</span><span class='line'>[[ 4  5]
</span><span class='line'> [ 7  8]
</span><span class='line'> [10 11]]
</span><span class='line'>对列使用高级索引来切片：
</span><span class='line'>[[ 4  5]
</span><span class='line'> [ 7  8]
</span><span class='line'> [10 11]]</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>布尔索引</h3>

<h4>当结果对象是布尔运算(例如比较运算符)的结果时，将使用此类型的高级索引。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x = np.array([[  0,  1,  2],[  3,  4,  5],[  6,  7,  8],[  9,  10,  11]])
</span><span class='line'>x
</span><span class='line'>array([[ 0,  1,  2],
</span><span class='line'>       [ 3,  4,  5],
</span><span class='line'>       [ 6,  7,  8],
</span><span class='line'>       [ 9, 10, 11]])
</span><span class='line'>x[x &gt; 5]
</span><span class='line'>array([ 6,  7,  8,  9, 10, 11])</span></code></pre></td></tr></table></div></figure>


<h4>这个例子使用了~(取补运算符)来过滤NaN。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.array([np.nan,  1,2,np.nan,3,4,5])
</span><span class='line'>a
</span><span class='line'>array([nan,  1.,  2., nan,  3.,  4.,  5.])
</span><span class='line'>a[np.isnan(a)]
</span><span class='line'>array([nan, nan])
</span><span class='line'>a[~np.isnan(a)]
</span><span class='line'>array([1., 2., 3., 4., 5.])</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.array([1,  2+6j,  5,  3.5+5j])
</span><span class='line'>a[np.iscomplex(a)]
</span><span class='line'>array([2. +6.j, 3.5+5.j])</span></code></pre></td></tr></table></div></figure>


<h4>还有很多is的内置函数可以再IDE中查询</h4>

<h4><a href="https://www.yiibai.com/numpy/numpy_array_attributes.html">https://www.yiibai.com/numpy/numpy_array_attributes.html</a></h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy - NumPy - 切片和索引⑦]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy8/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy8</id>
    <content type="html"><![CDATA[<h1>NumPy - 切片和索引</h1>

<h4>ndarray对象的内容可以通过索引或切片来访问和修改，就像 Python 的内置容器对象一样。</h4>

<h4>如前所述，ndarray对象中的元素遵循基于零的索引。 有三种可用的索引方法类型： 字段访问，基本切片和高级索引。</h4>

<h4>基本切片是 Python 中基本切片概念到 n 维的扩展。 通过将start，stop和step参数提供给内置的slice函数来构造一个 Python slice对象。 此slice对象被传递给数组来提取数组的一部分。</h4>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.arange(10)
</span><span class='line'>a
</span><span class='line'>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</span><span class='line'>a[s]
</span><span class='line'>array([2, 4, 6])</span></code></pre></td></tr></table></div></figure>


<h4>通过将由冒号分隔的切片参数(start:stop:step)直接提供给ndarray对象，也可以获得相同的结果</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a[1:4:2]
</span><span class='line'>array([1, 3])
</span><span class='line'>a[2]
</span><span class='line'>2</span></code></pre></td></tr></table></div></figure>


<h4>二维数组的切片</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>行的切片
</span><span class='line'>a = np.array([[1,2,3],[3,4,5],[4,5,6]])
</span><span class='line'>a
</span><span class='line'>array([[1, 2, 3],
</span><span class='line'>       [3, 4, 5],
</span><span class='line'>       [4, 5, 6]])
</span><span class='line'>a[1:]
</span><span class='line'>array([[3, 4, 5],
</span><span class='line'>       [4, 5, 6]])
</span><span class='line'>a[1:2]
</span><span class='line'>array([[3, 4, 5]])
</span><span class='line'>a[1:3]
</span><span class='line'>array([[3, 4, 5],
</span><span class='line'>       [4, 5, 6]])</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>列的切片
</span><span class='line'>a[:,1]
</span><span class='line'>array([2, 4, 5])
</span><span class='line'>a[:,1:3]
</span><span class='line'>array([[2, 3],
</span><span class='line'>       [4, 5],
</span><span class='line'>       [5, 6]])</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>行列共切
</span><span class='line'>a[:2,1:]
</span><span class='line'>array([[2, 3],
</span><span class='line'>       [4, 5]])</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a[:,1]
</span><span class='line'>array([2, 4, 5])
</span><span class='line'>a[:,2]
</span><span class='line'>array([3, 5, 6])</span></code></pre></td></tr></table></div></figure>


<h4>切片还可以包括省略号(&hellip;)，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的ndarray。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a[...,1]
</span><span class='line'>array([2, 4, 5])
</span><span class='line'>a[1,...]
</span><span class='line'>array([3, 4, 5])</span></code></pre></td></tr></table></div></figure>


<h4><a href="https://www.yiibai.com/numpy/numpy_array_attributes.html">https://www.yiibai.com/numpy/numpy_array_attributes.html</a></h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy - NumPy - 来自数值范围的数组⑥]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy7/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy7</id>
    <content type="html"><![CDATA[<h1>NumPy - 来自数值范围的数组</h1>

<hr />

<ul>
<li>numpy.arange：包含给定范围内的等间隔值。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.arange(start, stop, step, dtype)</span></code></pre></td></tr></table></div></figure>


<ol>
<li>start 范围的起始值，默认为0</li>
<li>stop 范围的终止值(不包含)</li>
<li>step 两个值的间隔，默认为1</li>
<li>dtype 返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.arange(0,100,2,dtype=float)
</span><span class='line'>a
</span><span class='line'>array([ 0.,  2.,  4.,  6.,  8., 10., 12., 14., 16., 18., 20., 22., 24.,
</span><span class='line'>       26., 28., 30., 32., 34., 36., 38., 40., 42., 44., 46., 48., 50.,
</span><span class='line'>       52., 54., 56., 58., 60., 62., 64., 66., 68., 70., 72., 74., 76.,
</span><span class='line'>       78., 80., 82., 84., 86., 88., 90., 92., 94., 96., 98.])</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>numpy.linspace 此函数类似于arange()函数。 在此函数中，指定了范围之间的均匀间隔数量，而不是步长</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.linspace(start, stop, num, endpoint, retstep, dtype)</span></code></pre></td></tr></table></div></figure>


<ol>
<li>start 序列的起始值</li>
<li>stop 序列的终止值，如果endpoint为true，该值包含于序列中</li>
<li>num 要生成的等间隔样例数量，默认为50</li>
<li>endpoint 序列中是否包含stop值，默认为ture</li>
<li>retstep 如果为true，返回样例，以及连续数字之间的步长</li>
<li>dtype 输出ndarray的数据类型</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.linspace(10,20,5) #10/5-1 5个数
</span><span class='line'>a
</span><span class='line'>array([10. , 12.5, 15. , 17.5, 20. ])
</span><span class='line'>a = np.linspace(10,20,6) #10/6-1 6个数
</span><span class='line'>a
</span><span class='line'>array([10., 12., 14., 16., 18., 20.])
</span><span class='line'>a = np.linspace(10,20,7) #10/7 7个数
</span><span class='line'>a
</span><span class='line'>array([10.        , 11.66666667, 13.33333333, 15.        , 16.66666667,
</span><span class='line'>       18.33333333, 20.        ])</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.linspace(10,20,5,endpoint=False) #10/5  5个数不包含20
</span><span class='line'>a
</span><span class='line'>array([10., 12., 14., 16., 18.])
</span><span class='line'>a = np.linspace(10,20,5,retstep=True)
</span><span class='line'>a
</span><span class='line'>(array([10. , 12.5, 15. , 17.5, 20. ]), 2.5)</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>numpy.logspace:此函数返回一个ndarray对象，其中包含在对数刻度上均匀分布的数字。 刻度的开始和结束端点是某个底数的幂，通常为 10。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.logspace(start, stop, num, endpoint, base, dtype)</span></code></pre></td></tr></table></div></figure>


<ol>
<li>start 起始值是base ** start</li>
<li>stop 终止值是base ** stop</li>
<li>num 范围内的数值数量，默认为50</li>
<li>endpoint 如果为true，终止值包含在输出数组当中</li>
<li>base 对数空间的底数，默认为10</li>
<li>dtype 输出数组的数据类型，如果没有提供，则取决于其它参数</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.logspace(1.0,  2.0, num =  10) #1=log10  2=log10^2
</span><span class='line'>a
</span><span class='line'>array([ 10.        ,  12.91549665,  16.68100537,  21.5443469 ,
</span><span class='line'>        27.82559402,  35.93813664,  46.41588834,  59.94842503,
</span><span class='line'>        77.42636827, 100.        ])
</span><span class='line'>a = np.logspace(1,10,num =  10,  base  =  2)
</span><span class='line'>a
</span><span class='line'>array([   2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.,  512.,
</span><span class='line'>       1024.])</span></code></pre></td></tr></table></div></figure>


<h4><a href="https://www.yiibai.com/numpy/numpy_array_attributes.html">https://www.yiibai.com/numpy/numpy_array_attributes.html</a></h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy - NumPy - 来自现有数据的数组⑤]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy6/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy6</id>
    <content type="html"><![CDATA[<h1>NumPy - 来自现有数据的数组-从现有数据创建数组。</h1>

<hr />

<ul>
<li>numpy.asarray：此函数类似于numpy.array，除了它有较少的参数。 这个例程对于将 Python 序列转换为ndarray非常有用。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.asarray(a, dtype = None, order = None)</span></code></pre></td></tr></table></div></figure>


<ol>
<li>a 任意形式的输入参数，比如列表、列表的元组、元组、元组的元组、元组的列表</li>
<li>dtype 通常，输入数据的类型会应用到返回的ndarray</li>
<li>order &lsquo;C'为按行的 C 风格数组，'F'为按列的 Fortran 风格数组</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x=[(1,2,3),(4,5,6)]
</span><span class='line'>a= np.asarray(x,dtype=np.float32,order='C')
</span><span class='line'>print(a)
</span><span class='line'>[[1. 2. 3.]
</span><span class='line'> [4. 5. 6.]]
</span><span class='line'>y=[['1','2','3'],[1,2,3]]
</span><span class='line'>print(y)
</span><span class='line'>[['1', '2', '3'], [1, 2, 3]]
</span><span class='line'>a = np.asarray(y,dtype=np.float32,order='C')
</span><span class='line'>print(a)
</span><span class='line'>[[1. 2. 3.]
</span><span class='line'> [1. 2. 3.]]
</span><span class='line'>a = np.asarray(y,dtype=np.float32,order='F')
</span><span class='line'>print(a)
</span><span class='line'>[[1. 2. 3.]
</span><span class='line'> [1. 2. 3.]]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>numpy.frombuffer:此函数将缓冲区解释为一维数组。 暴露缓冲区接口的任何对象都用作参数来返回ndarray</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</span></code></pre></td></tr></table></div></figure>


<ol>
<li>buffer 任何暴露缓冲区接口的对象</li>
<li>dtype 返回数组的数据类型，默认为float</li>
<li>count 需要读取的数据数量，默认为-1，读取所有数据</li>
<li>offset 需要读取的起始位置，默认为0</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import numpy as np 
</span><span class='line'>s =  'Hello World' 
</span><span class='line'>a = np.frombuffer(s, dtype =  'S1')  
</span><span class='line'>print a
</span><span class='line'>['H'  'e'  'l'  'l'  'o'  ' '  'W'  'o'  'r'  'l'  'd']
</span><span class='line'>注意：python中没实现，必须把str变成byte后就可以了</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>numpy.fromiter：任何可迭代对象构建一个ndarray对象，返回一个新的一维数组。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.fromiter(iterable, dtype, count = -1)</span></code></pre></td></tr></table></div></figure>


<ol>
<li>iterable 任何可迭代对象</li>
<li>dtype 返回数组的数据类型</li>
<li>count 需要读取的数据数量，默认为-1，读取所有数据</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b=[i for i in range(10)]
</span><span class='line'>b
</span><span class='line'>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</span><span class='line'>b= iter(b)
</span><span class='line'>print(b)
</span><span class='line'>&lt;list_iterator object at 0x04BFC770&gt;
</span><span class='line'>a = np.fromiter(b,dtype=int)
</span><span class='line'>a
</span><span class='line'>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</span><span class='line'>print(a)
</span><span class='line'>[0 1 2 3 4 5 6 7 8 9]
</span><span class='line'>c=[i for i in range(10)]
</span><span class='line'>a = np.fromiter(c,dtype=int)
</span><span class='line'>print(a)
</span><span class='line'>[0 1 2 3 4 5 6 7 8 9]
</span><span class='line'>注意：str，list，tuple，dict，set都是可迭代对象所以都可以使用</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>fromstring：从字符串中读取元素组成数组</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fromstring(string, dtype=float, count=-1, sep='')</span></code></pre></td></tr></table></div></figure>


<ol>
<li>string 字符串对象</li>
<li>dtype 返回数组的数据类型</li>
<li>count 读取几个 -1 去读</li>
<li>sep 用什么分隔</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>np.fromstring('1 2', dtype=int, sep=' ')
</span><span class='line'>array([1, 2])
</span><span class='line'>np.fromstring('1, 2', dtype=int, sep=',')
</span><span class='line'>array([1, 2])
</span><span class='line'>注意：目前只能是这样的字符串，其他没试验成功
</span><span class='line'>c= '1 2 3'
</span><span class='line'>a = np.fromstring(c,dtype=int,count=2,sep=' ')
</span><span class='line'>array([1, 2])</span></code></pre></td></tr></table></div></figure>


<ul>
<li>np.fromfile 从文件中读，生成数组</li>
<li>np.fromfunction 从函数中读，生成数组</li>
<li>np.fromregex 从正则表达式读，生成数组

<h4><a href="https://www.yiibai.com/numpy/numpy_array_attributes.html">https://www.yiibai.com/numpy/numpy_array_attributes.html</a></h4></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy - NumPy - 数组创建例程④]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy5/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy5</id>
    <content type="html"><![CDATA[<h1>NumPy - 数组创建例程</h1>

<hr />

<ul>
<li>numpy.empty</li>
</ul>


<h5>它创建指定形状和dtype的未初始化数组。 它使用以下构造函数：</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.empty(shape, dtype = float, order = 'C')</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Shape 空数组的形状，整数或整数元组</li>
<li>Dtype 所需的输出数组类型，可选</li>
<li>Order &lsquo;C'为按行的 C 风格数组，'F'为按列的 Fortran 风格数组</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.empty((3,3),dtype=int)
</span><span class='line'>print(a)
</span><span class='line'>[[  2   0   0]
</span><span class='line'> [  0   0   0]
</span><span class='line'> [464   0   0]]
</span><span class='line'>注意：数组元素为随机值，因为它们未初始化。</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>numpy.zeros返回特定大小，以 0 填充的新数组</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.zeros(shape, dtype = float, order = 'C')
</span><span class='line'>a= np.zeros((3,3),dtype=int)
</span><span class='line'>print(a)
</span><span class='line'>[[0 0 0]
</span><span class='line'> [0 0 0]
</span><span class='line'> [0 0 0]]
</span><span class='line'>注意：创建全为0的3*3的数组</span></code></pre></td></tr></table></div></figure>


<ul>
<li>numpy.ones返回特定大小，以 1 填充的新数组。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.ones((3,3),dtype=int)
</span><span class='line'>print(a)
</span><span class='line'>[[1 1 1]
</span><span class='line'> [1 1 1]
</span><span class='line'> [1 1 1]]</span></code></pre></td></tr></table></div></figure>


<h4><a href="https://www.yiibai.com/numpy/numpy_array_attributes.html">https://www.yiibai.com/numpy/numpy_array_attributes.html</a></h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy - NumPy - 数组属性③]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy4/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy4</id>
    <content type="html"><![CDATA[<h1>NumPy - 数组属性</h1>

<hr />

<ul>
<li>ndarray.shape   返回一个包含数组维度的元组，它也可以用于调整数组大小。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.array([[4,5,6],[7,8,9]])
</span><span class='line'>a.shape
</span><span class='line'>(2, 3)
</span><span class='line'>因为我们创建的数组是2行3列的数组，所以返回(2,3)</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>调整数组大小
</span><span class='line'>a.shape = (3,2)
</span><span class='line'>print(a)
</span><span class='line'>[[4 5]
</span><span class='line'> [6 7]
</span><span class='line'> [8 9]]
</span><span class='line'>*因为有6个元素，所以只能重新调整为乘积为6的矩阵：如：1*6-2*3-3*2-6*1  维度不会变化
</span><span class='line'>a.shape = (1,6)
</span><span class='line'>print(a)
</span><span class='line'>[[4 5 6 7 8 9]]
</span><span class='line'>a.shape = (6,1)
</span><span class='line'>print(a)
</span><span class='line'>[[4]
</span><span class='line'> [5]
</span><span class='line'> [6]
</span><span class='line'> [7]
</span><span class='line'> [8]
</span><span class='line'> [9]]</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>ndarray.reshape  调整数组大小</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a.reshape(2,3)
</span><span class='line'>array([[4, 5, 6],
</span><span class='line'>       [7, 8, 9]])
</span><span class='line'>这个属性主要是用来调整矩阵的维度的，调整的规则同上</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>ndarray.ndim  这一数组属性返回数组的维数。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.arange(24)
</span><span class='line'>[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
</span><span class='line'>a.reshape(4,6)
</span><span class='line'>array([[ 0,  1,  2,  3,  4,  5],
</span><span class='line'>       [ 6,  7,  8,  9, 10, 11],
</span><span class='line'>       [12, 13, 14, 15, 16, 17],
</span><span class='line'>       [18, 19, 20, 21, 22, 23]])
</span><span class='line'>a.reshape(4,2,3)
</span><span class='line'>array([[[ 0,  1,  2],
</span><span class='line'>        [ 3,  4,  5]],
</span><span class='line'>       [[ 6,  7,  8],
</span><span class='line'>        [ 9, 10, 11]],
</span><span class='line'>       [[12, 13, 14],
</span><span class='line'>        [15, 16, 17]],
</span><span class='line'>       [[18, 19, 20],
</span><span class='line'>        [21, 22, 23]]])
</span><span class='line'>共有24个元素，所以行*列*维度=24</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>ndarray.itemsize  这一数组属性返回数组中每个元素的字节单位长度。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a =np.array(a,dtype=np.int8) #int8=1byte
</span><span class='line'>print(a)
</span><span class='line'>[0 1 2 3 4 5]
</span><span class='line'>a.itemsize
</span><span class='line'>1
</span><span class='line'>a =np.array(a,dtype=np.float32)#float32=4byte
</span><span class='line'>a.itemsize
</span><span class='line'>4</span></code></pre></td></tr></table></div></figure>


<hr />

<ul>
<li>ndarray.flags</li>
</ul>


<h4>ndarray对象拥有以下属性。这个函数返回了它们的当前值。</h4>

<ol>
<li>C_CONTIGUOUS &copy; 数组位于单一的、C 风格的连续区段内</li>
<li>F_CONTIGUOUS (F) 数组位于单一的、Fortran 风格的连续区段内</li>
<li>OWNDATA (O) 数组的内存从其它对象处借用</li>
<li>WRITEABLE (W) 数据区域可写入。 将它设置为flase会锁定数据，使其只读</li>
<li>ALIGNED (A) 数据和任何元素会为硬件适当对齐</li>
<li>UPDATEIFCOPY (U) 这个数组是另一数组的副本。当这个数组释放时，源数组会由这个数组中的元素更新</li>
</ol>


<h4>示例下面的例子展示当前的标志。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>x = np.array([1,2,3,4,5])  
</span><span class='line'>print(x.flags)
</span><span class='line'>输出如下：
</span><span class='line'>C_CONTIGUOUS : True 
</span><span class='line'>F_CONTIGUOUS : True 
</span><span class='line'>OWNDATA : True 
</span><span class='line'>WRITEABLE : True 
</span><span class='line'>ALIGNED : True 
</span><span class='line'>UPDATEIFCOPY : False</span></code></pre></td></tr></table></div></figure>


<h4><a href="https://www.yiibai.com/numpy/numpy_array_attributes.html">https://www.yiibai.com/numpy/numpy_array_attributes.html</a></h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy - NumPy - 数据类型②]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy3/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy3</id>
    <content type="html"><![CDATA[<h1>NumPy - 数据类型</h1>

<ol>
<li>bool_   存储为一个字节的布尔值(真或假)</li>
<li>int_    默认整数，相当于 C 的long，通常为int32或int64</li>
<li>intc    相当于 C 的int，通常为int32或int64</li>
<li>intp    用于索引的整数，相当于 C 的size_t，通常为int32或int64</li>
<li>int     8字节(-128 ~ 127)</li>
<li>int16   16位整数(-32768 ~ 32767)</li>
<li>int32   32位整数(-2147483648 ~ 2147483647)</li>
<li>int64   64位整数(-9223372036854775808 ~ 9223372036854775807)</li>
<li>uint8   8位无符号整数(0 ~ 255)</li>
<li>uint16  16位无符号整数(0 ~ 65535)</li>
<li>uint32  32位无符号整数(0 ~ 4294967295)</li>
<li>uint64  64位无符号整数(0 ~ 18446744073709551615)</li>
<li>float_  float64的简写</li>
<li>float16 半精度浮点：符号位，5 位指数，10 位尾数</li>
<li>float32 单精度浮点：符号位，8 位指数，23 位尾数</li>
<li>float64 双精度浮点：符号位，11 位指数，52 位尾数</li>
<li>complex_complex 128的简写</li>
<li>complex64   复数，由两个 32 位浮点表示(实部和虚部)</li>
<li>complex128  复数，由两个 64 位浮点表示(实部和虚部)

<h4>NumPy 数字类型是dtype(数据类型)对象的实例，每个对象具有唯一的特征。 这些类型可以是np.bool_，np.float32等。</h4></li>
</ol>


<hr />

<h3>数据类型对象 (dtype)</h3>

<h4>数据类型对象描述了对应于数组的固定内存块的解释，取决于以下方面：</h4>

<ul>
<li><p>数据类型(整数、浮点或者 Python 对象)</p></li>
<li><p>数据大小</p></li>
<li><p>字节序(小端或大端)</p></li>
<li><p>在结构化类型的情况下，字段的名称，每个字段的数据类型，和每个字段占用的内存块部分。</p></li>
<li><p>如果数据类型是子序列，它的形状和数据类型。</p></li>
<li><p>字节顺序取决于数据类型的前缀&lt;或>。&lt;意味着编码是小端(最小有效字节存储在最小地址中)。>意味着编码是大端(最大有效字节存储在最小地址中)。</p></li>
</ul>


<h4>dtype可由一下语法构造：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.dtype(object, align, copy)</span></code></pre></td></tr></table></div></figure>


<h4>参数为：</h4>

<ul>
<li><p>Object：被转换为数据类型的对象。</p></li>
<li><p>Align：如果为true，则向字段添加间隔，使其类似 C 的结构体。</p></li>
<li><p>Copy? 生成dtype对象的新副本，如果为flase，结果是内建数据类型对象的引用。</p></li>
</ul>


<h3>示例 像创建列名一样创建数组</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dt = np.dtype([('age',bool)])
</span><span class='line'>a = np.array([12,13,14],dtype=dt)
</span><span class='line'>print(a)
</span><span class='line'>[( True,) ( True,) ( True,)]
</span><span class='line'>print(a['age'])
</span><span class='line'>[ True  True  True]
</span><span class='line'>dt = np.dtype([('age',int),('name',str)])
</span><span class='line'>a = np.array([(12,'a'),(13,'b')],dtype=dt)
</span><span class='line'>print(a)
</span><span class='line'>[(12, '') (13, '')]
</span><span class='line'>dt = np.dtype(('age',bool))
</span><span class='line'>student = np.dtype([('name','S20'),  ('age',  'i1'),  ('marks',  'f4')])
</span><span class='line'>a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
</span><span class='line'>print(a)
</span><span class='line'>[(b'abc', 21, 50.) (b'xyz', 18, 75.)]
</span><span class='line'>student = np.dtype([('name','str'),  ('age',  int),  ('marks',  float)])
</span><span class='line'>a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
</span><span class='line'>print(a)
</span><span class='line'>[('', 21, 50.) ('', 18, 75.)]
</span><span class='line'> student = np.dtype([('name',str),  ('age',  int),  ('marks',  float)])
</span><span class='line'>a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
</span><span class='line'>print(a)
</span><span class='line'>[('', 21, 50.) ('', 18, 75.)]
</span><span class='line'>student = np.dtype([('name','a'),  ('age',  'i'),  ('marks',  'f')])
</span><span class='line'>a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
</span><span class='line'>print(a)
</span><span class='line'>[(b'', 21, 50.) (b'', 18, 75.)]
</span><span class='line'>student = np.dtype([('name','S'),  ('age',  'i'),  ('marks',  'f')])
</span><span class='line'>a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)
</span><span class='line'>print(a)
</span><span class='line'>[(b'', 21, 50.) (b'', 18, 75.)]
</span><span class='line'>student = np.dtype([('name','S20'),  ('age',  'i'),  ('marks',  'f')])
</span><span class='line'>a = np.array([[('abc',  21,  50),('xyz',  18,  75)],[('fff',  21,  50),('eee',  18,  75)]], dtype = student)
</span><span class='line'>print(a)
</span><span class='line'>[[(b'abc', 21, 50.) (b'xyz', 18, 75.)]
</span><span class='line'> [(b'fff', 21, 50.) (b'eee', 18, 75.)]]
</span><span class='line'>print(a['name'])
</span><span class='line'>[[b'abc' b'xyz']
</span><span class='line'> [b'fff' b'eee']]</span></code></pre></td></tr></table></div></figure>


<h4>每个内建类型都有一个唯一定义它的字符代码：</h4>

<ul>
<li><p>&lsquo;b'：布尔值</p></li>
<li><p>&lsquo;i'：符号整数</p></li>
<li><p>&lsquo;u'：无符号整数</p></li>
<li><p>&lsquo;f'：浮点</p></li>
<li><p>&lsquo;c'：复数浮点</p></li>
<li><p>&rsquo;m'：时间间隔</p></li>
<li><p>&rsquo;M'：日期时间</p></li>
<li><p>&lsquo;O'：Python 对象</p></li>
<li><p>&rsquo;S', &lsquo;a'：字节串</p></li>
<li><p>&lsquo;U'：Unicode</p></li>
<li><p>&lsquo;V'：原始数据(void)</p></li>
</ul>


<h4><a href="https://www.yiibai.com/numpy/numpy_array_attributes.html">https://www.yiibai.com/numpy/numpy_array_attributes.html</a></h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy - Ndarray 对象①]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy2</id>
    <content type="html"><![CDATA[<h1>Ndarray 对象</h1>

<h4>NumPy 中定义的最重要的对象是称为 ndarray 的 N 维数组类型。 它描述相同类型的元素集合。 可以使用基于<code>零</code>的索引访问集合中的项目。</h4>

<h4>ndarray中的每个元素在内存中使用相同大小的块。 ndarray中的每个元素是数据类型对象的对象(称为 dtype)。</h4>

<h4>从ndarray对象提取的任何元素(通过切片)由一个数组标量类型的 Python 对象表示。 下图显示了ndarray，数据类型对象(dtype)和数组标量类型之间的关系。</h4>

<p><img src="http://shangyajun6943.github.io/images/np/430090425_51678.jpg" alt="images" /></p>

<h4>基本的ndarray是使用 NumPy 中的数组函数创建的，如下所示：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.array</span></code></pre></td></tr></table></div></figure>


<h4>它从<code>任何暴露数组接口的对象</code>，或从返回数组的任何方法创建一个ndarray。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</span></code></pre></td></tr></table></div></figure>


<ol>
<li>object 任何暴露数组接口方法的对象都会返回一个数组或任何(嵌套)序列。</li>
<li>dtype 数组的所需数据类型，可选。</li>
<li>copy 可选，默认为true，对象是否被复制。</li>
<li>order C(按行)、F(按列)或A(任意，默认)。</li>
<li>subok 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类。</li>
<li>ndimin 指定返回数组的最小维数。</li>
</ol>


<h4>示例 1 一维数组</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.array([1,2,3])
</span><span class='line'>print(a)
</span><span class='line'>[1 2 3]</span></code></pre></td></tr></table></div></figure>


<h4>示例 2 多维数组</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.array([[1,2,3],[4,5,6],[7,8,9]])
</span><span class='line'>print(a)
</span><span class='line'>[[1 2 3]
</span><span class='line'>[4 5 6]
</span><span class='line'>[7 8 9]]</span></code></pre></td></tr></table></div></figure>


<h4>示例 3 最小维度</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.array([1,2,3],ndmin=1)
</span><span class='line'>print(a)
</span><span class='line'>[1 2 3]
</span><span class='line'>a = np.array([1,2,3],ndmin=2)
</span><span class='line'>print(a)
</span><span class='line'>[[1 2 3]]
</span><span class='line'>a = np.array([1,2,3],ndmin=3)
</span><span class='line'>print(a)
</span><span class='line'>[[[1 2 3]]]</span></code></pre></td></tr></table></div></figure>


<h4>示例 4 dtype 参数</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.array([1,2,3],dtype=complex)
</span><span class='line'>print(a)
</span><span class='line'>[1.+0.j 2.+0.j 3.+0.j]
</span><span class='line'>a = np.array([1,2,3],dtype=int)
</span><span class='line'>print(a)
</span><span class='line'>[1 2 3]
</span><span class='line'>a = np.array([1,2,3],dtype=str)
</span><span class='line'> print(a)
</span><span class='line'>['1' '2' '3']
</span><span class='line'>a = np.array([1,2,3],dtype=bool)
</span><span class='line'>print(a)
</span><span class='line'>[ True  True  True]</span></code></pre></td></tr></table></div></figure>


<h2>ndarray 对象由计算机内存中的一维连续区域组成，带有将每个元素映射到内存块中某个位置的索引方案。 内存块以按行(C 风格)或按列(FORTRAN 或 MatLab 风格)的方式保存元素。</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy -数组操作⑪]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy12/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy12</id>
    <content type="html"><![CDATA[<h1>NumPy - 数组操作</h1>

<h4>NumPy包中有几个例程用于处理ndarray对象中的元素。 它们可以分为以下类型：</h4>

<ol>
<li>reshape 不改变数据的条件下修改形状</li>
<li>flat 数组上的一维迭代器</li>
<li>flatten 返回折叠为一维的数组副本</li>
<li>ravel 返回连续的展开数组</li>
</ol>


<hr />

<h3>numpy.reshape</h3>

<h4>这个函数在不改变数据的条件下修改形状，它接受如下参数：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.reshape(arr, newshape, order')</span></code></pre></td></tr></table></div></figure>


<ol>
<li>arr：要修改形状的数组</li>
<li>newshape：整数或者整数数组，新的形状应当兼容原有形状</li>
<li>order：'C'为 C 风格顺序，'F'为 F 风格顺序，'A'为保留原顺序。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import numpy as np
</span><span class='line'>a = np.arange(10)
</span><span class='line'>a
</span><span class='line'>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</span><span class='line'>b = np.reshape(a,(2,5),order='F')
</span><span class='line'>b
</span><span class='line'>array([[0, 2, 4, 6, 8],
</span><span class='line'>       [1, 3, 5, 7, 9]])</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>numpy.ndarray.flat</h3>

<h4>该函数返回数组上的一维迭代器，行为类似 Python 内建的迭代器。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.arange(10).reshape(2,5)
</span><span class='line'>a
</span><span class='line'>array([[0, 1, 2, 3, 4],
</span><span class='line'>       [5, 6, 7, 8, 9]])
</span><span class='line'>a.flat[3]
</span><span class='line'># 返回展开数组中的下标的对应元素
</span><span class='line'>3
</span><span class='line'>#返回数组上的一维迭代器
</span><span class='line'>a.flat
</span><span class='line'>&lt;numpy.flatiter object at 0x05E12ED0&gt;
</span><span class='line'>for i in a.flat:
</span><span class='line'>  print(i)
</span><span class='line'>0
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>numpy.ndarray.flatten</h2>

<h4>该函数返回折叠为一维的数组副本，函数接受下列参数：</h4>

<ul>
<li>order：'C' — 按行，'F' — 按列，'A' — 原顺序，'k' — 元素在内存中的出现顺序。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.arange(8).reshape(2,4)
</span><span class='line'>a
</span><span class='line'>array([[0, 1, 2, 3],
</span><span class='line'>       [4, 5, 6, 7]])
</span><span class='line'>a.flatten
</span><span class='line'>&lt;built-in method flatten of numpy.ndarray object at 0x061F7110&gt;
</span><span class='line'>a.flatten()
</span><span class='line'>array([0, 1, 2, 3, 4, 5, 6, 7])
</span><span class='line'>a.flat()
</span><span class='line'>Traceback (most recent call last):
</span><span class='line'>  File "&lt;pyshell#17&gt;", line 1, in &lt;module&gt;
</span><span class='line'>    a.flat()
</span><span class='line'>TypeError: 'numpy.flatiter' object is not callable
</span><span class='line'>a.flatten(order='C')
</span><span class='line'>array([0, 1, 2, 3, 4, 5, 6, 7])
</span><span class='line'>a.flatten(order='F')
</span><span class='line'>array([0, 4, 1, 5, 2, 6, 3, 7])
</span><span class='line'>a.flatten(order='A')
</span><span class='line'>array([0, 1, 2, 3, 4, 5, 6, 7])
</span><span class='line'>a.flatten(order='k')
</span><span class='line'>array([0, 1, 2, 3, 4, 5, 6, 7])</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>numpy.ravel</h3>

<h4>这个函数返回展开的一维数组，并且按需生成副本。返回的数组和输入数组拥有相同数据类型。这个函数接受两个参数。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.ravel(arr, order)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>order：'C' — 按行，'F' — 按列，'A' — 原顺序，'k' — 元素在内存中的出现顺序。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.arange(8).reshape(2,4)
</span><span class='line'>a.ravel
</span><span class='line'>&lt;built-in method ravel of numpy.ndarray object at 0x061F7160&gt;
</span><span class='line'>a.ravel()
</span><span class='line'>array([0, 1, 2, 3, 4, 5, 6, 7])
</span><span class='line'>a
</span><span class='line'>array([[0, 1, 2, 3],
</span><span class='line'>       [4, 5, 6, 7]])
</span><span class='line'>b = a.ravel()
</span><span class='line'>b
</span><span class='line'>array([0, 1, 2, 3, 4, 5, 6, 7])
</span><span class='line'>c = a.ravel(order='F')
</span><span class='line'>c
</span><span class='line'>array([0, 4, 1, 5, 2, 6, 3, 7])</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>翻转操作</h2>

<ol>
<li>transpose 翻转数组的维度</li>
<li>ndarray.T 和self.transpose()相同</li>
<li>rollaxis 向后滚动指定的轴</li>
<li>swapaxes 互换数组的两个轴</li>
</ol>


<h3>numpy.transpose</h3>

<h4>这个函数翻转给定数组的维度。如果可能的话它会返回一个视图。函数接受下列参数：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.transpose(arr, axes)
</span><span class='line'>arr：要转置的数组
</span><span class='line'>axes：整数的列表，对应维度，通常所有维度都会翻转。</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = np.arange(12).reshape(3,4)
</span><span class='line'>a
</span><span class='line'>array([[ 0,  1,  2,  3],
</span><span class='line'>       [ 4,  5,  6,  7],
</span><span class='line'>       [ 8,  9, 10, 11]])
</span><span class='line'>np.transpose(a)
</span><span class='line'>array([[ 0,  4,  8],
</span><span class='line'>       [ 1,  5,  9],
</span><span class='line'>       [ 2,  6, 10],
</span><span class='line'>       [ 3,  7, 11]])
</span><span class='line'>a.transpose
</span><span class='line'>&lt;built-in method transpose of numpy.ndarray object at 0x061F70E8&gt;
</span><span class='line'>a.transpose()
</span><span class='line'>array([[ 0,  4,  8],
</span><span class='line'>       [ 1,  5,  9],
</span><span class='line'>       [ 2,  6, 10],
</span><span class='line'>       [ 3,  7, 11]])</span></code></pre></td></tr></table></div></figure>


<h3>numpy.ndarray.T该函数属于ndarray类，行为类似于numpy.transpose。</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a.transpose()
</span><span class='line'>array([[ 0,  4,  8],
</span><span class='line'>       [ 1,  5,  9],
</span><span class='line'>       [ 2,  6, 10],
</span><span class='line'>       [ 3,  7, 11]])
</span><span class='line'>a = np.arange(12).reshape(3,4)
</span><span class='line'>a.T
</span><span class='line'>array([[ 0,  4,  8],
</span><span class='line'>       [ 1,  5,  9],
</span><span class='line'>       [ 2,  6, 10],
</span><span class='line'>       [ 3,  7, 11]])</span></code></pre></td></tr></table></div></figure>


<h3>numpy.rollaxis</h3>

<h4>该函数向后滚动特定的轴，直到一个特定位置。这个函数接受三个参数：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>numpy.rollaxis(arr, axis, start)
</span><span class='line'>arr：输入数组
</span><span class='line'>axis：要向后滚动的轴，其它轴的相对位置不会改变start：默认为零，表示完整的滚动。会滚动到特定位置。</span></code></pre></td></tr></table></div></figure>


<h4><a href="https://www.yiibai.com/numpy/numpy_array_attributes.html">https://www.yiibai.com/numpy/numpy_array_attributes.html</a></h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy -NumPy -数组上的迭代⑩]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy11/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy11</id>
    <content type="html"><![CDATA[<h1>NumPy - 数组上的迭代</h1>

<h4>NumPy 包包含一个迭代器对象numpy.nditer。 它是一个有效的多维迭代器对象，可以用于在数组上进行迭代。 数组的每个元素可使用 Python 的标准Iterator接口来访问。让我们使用arange()函数创建一个 3X4 数组，并使用nditer对它进行迭代。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a=np.arange(0,60,5)
</span><span class='line'>a
</span><span class='line'>array([ 0,  5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55])
</span><span class='line'>a.reshape(4,3)
</span><span class='line'>array([[ 0,  5, 10],
</span><span class='line'>       [15, 20, 25],
</span><span class='line'>       [30, 35, 40],
</span><span class='line'>       [45, 50, 55]])
</span><span class='line'>for i in np.nditer(a):
</span><span class='line'>  print(i)    
</span><span class='line'>0
</span><span class='line'>5
</span><span class='line'>10
</span><span class='line'>15
</span><span class='line'>20
</span><span class='line'>25
</span><span class='line'>30
</span><span class='line'>35
</span><span class='line'>40
</span><span class='line'>45
</span><span class='line'>50
</span><span class='line'>55</span></code></pre></td></tr></table></div></figure>


<h4>迭代的顺序匹配数组的内容布局，而不考虑特定的排序。 这可以通过迭代上述数组的转置来看到。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b = a.reshape(4,3)
</span><span class='line'>b
</span><span class='line'>array([[ 0,  5, 10],
</span><span class='line'>       [15, 20, 25],
</span><span class='line'>       [30, 35, 40],
</span><span class='line'>       [45, 50, 55]])
</span><span class='line'>c = b.T
</span><span class='line'>c
</span><span class='line'>array([[ 0, 15, 30, 45],
</span><span class='line'>       [ 5, 20, 35, 50],
</span><span class='line'>       [10, 25, 40, 55]])
</span><span class='line'>for i in np.nditer(c):
</span><span class='line'>  print(i)    
</span><span class='line'>0
</span><span class='line'>5
</span><span class='line'>10
</span><span class='line'>15
</span><span class='line'>20
</span><span class='line'>25
</span><span class='line'>30
</span><span class='line'>35
</span><span class='line'>40
</span><span class='line'>45
</span><span class='line'>50
</span><span class='line'>55</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>迭代顺序-不同的存储分格，迭代的顺序不同</h2>

<h4>如果相同元素使用 F 风格顺序存储，则迭代器选择以更有效的方式对数组进行迭代。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b = a.reshape(4,3)
</span><span class='line'>b
</span><span class='line'>array([[ 0,  5, 10],
</span><span class='line'>       [15, 20, 25],
</span><span class='line'>       [30, 35, 40],
</span><span class='line'>       [45, 50, 55]])
</span><span class='line'>c = b.all
</span><span class='line'>c
</span><span class='line'>&lt;built-in method all of numpy.ndarray object at 0x06217520&gt;
</span><span class='line'>c = b.any
</span><span class='line'>c
</span><span class='line'>&lt;built-in method any of numpy.ndarray object at 0x06217520&gt;
</span><span class='line'>c = b.T
</span><span class='line'>c
</span><span class='line'>array([[ 0, 15, 30, 45],
</span><span class='line'>       [ 5, 20, 35, 50],
</span><span class='line'>       [10, 25, 40, 55]])
</span><span class='line'>d = c.copy(order='C')
</span><span class='line'>d
</span><span class='line'>array([[ 0, 15, 30, 45],
</span><span class='line'>       [ 5, 20, 35, 50],
</span><span class='line'>       [10, 25, 40, 55]])
</span><span class='line'>for i in np.nditer(d):
</span><span class='line'>  print(i)    
</span><span class='line'>0
</span><span class='line'>15
</span><span class='line'>30
</span><span class='line'>45
</span><span class='line'>5
</span><span class='line'>20
</span><span class='line'>35
</span><span class='line'>50
</span><span class='line'>10
</span><span class='line'>25
</span><span class='line'>40
</span><span class='line'>55
</span><span class='line'>e = c.copy(order='F')
</span><span class='line'>e
</span><span class='line'>array([[ 0, 15, 30, 45],
</span><span class='line'>       [ 5, 20, 35, 50],
</span><span class='line'>       [10, 25, 40, 55]])
</span><span class='line'>for i in np.nditer(e):
</span><span class='line'>  print(i)    
</span><span class='line'>0
</span><span class='line'>5
</span><span class='line'>10
</span><span class='line'>15
</span><span class='line'>20
</span><span class='line'>25
</span><span class='line'>30
</span><span class='line'>35
</span><span class='line'>40
</span><span class='line'>45
</span><span class='line'>50
</span><span class='line'>55</span></code></pre></td></tr></table></div></figure>


<h4>可以通过显式提醒，来强制nditer对象使用某种顺序：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b
</span><span class='line'>array([[ 0,  5, 10],
</span><span class='line'>       [15, 20, 25],
</span><span class='line'>       [30, 35, 40],
</span><span class='line'>       [45, 50, 55]])
</span><span class='line'>for i in np.nditer(b,order='C'):
</span><span class='line'>  print(i)
</span><span class='line'>0
</span><span class='line'>5
</span><span class='line'>10
</span><span class='line'>15
</span><span class='line'>20
</span><span class='line'>25
</span><span class='line'>30
</span><span class='line'>35
</span><span class='line'>40
</span><span class='line'>45
</span><span class='line'>50
</span><span class='line'>55
</span><span class='line'>for i in np.nditer(b,order='F'):
</span><span class='line'>  print(i)    
</span><span class='line'>0
</span><span class='line'>15
</span><span class='line'>30
</span><span class='line'>45
</span><span class='line'>5
</span><span class='line'>20
</span><span class='line'>35
</span><span class='line'>50
</span><span class='line'>10
</span><span class='line'>25
</span><span class='line'>40
</span><span class='line'>55</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>修改数组的值</h2>

<h4>nditer对象有另一个可选参数op_flags。 其默认值为只读，但可以设置为读写或只写模式。 这将允许使用此迭代器修改数组元素。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b
</span><span class='line'>array([[ 0,  5, 10],
</span><span class='line'>       [15, 20, 25],
</span><span class='line'>       [30, 35, 40],
</span><span class='line'>       [45, 50, 55]])
</span><span class='line'>b[0,0]
</span><span class='line'>0
</span><span class='line'>b[0,0] = 20
</span><span class='line'>b
</span><span class='line'>array([[20,  5, 10],
</span><span class='line'>       [15, 20, 25],
</span><span class='line'>       [30, 35, 40],
</span><span class='line'>       [45, 50, 55]])
</span><span class='line'>for i in np.nditer(b,op_flags=['readwrite']):
</span><span class='line'>  i[...] = i*2
</span><span class='line'>b
</span><span class='line'>array([[ 40,  10,  20],
</span><span class='line'>       [ 30,  40,  50],
</span><span class='line'>       [ 60,  70,  80],
</span><span class='line'>       [ 90, 100, 110]])</span></code></pre></td></tr></table></div></figure>


<h2>外部循环</h2>

<h4>nditer类的构造器拥有flags参数，它可以接受下列值：</h4>

<ol>
<li>c_index 可以跟踪 C 顺序的索引</li>
<li>f_index 可以跟踪 Fortran 顺序的索引</li>
<li>multi-index 每次迭代可以跟踪一种索引类型</li>
<li>external_loop 给出的值是具有多个值的一维数组，而不是零维数组</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>b
</span><span class='line'>array([[ 40,  10,  20],
</span><span class='line'>       [ 30,  40,  50],
</span><span class='line'>       [ 60,  70,  80],
</span><span class='line'>       [ 90, 100, 110]])
</span><span class='line'>for i in np.nditer(b,flags= ['external_loop'],order='F'):
</span><span class='line'>  print(i)
</span><span class='line'>[40 30 60 90]
</span><span class='line'>[ 10  40  70 100]
</span><span class='line'>[ 20  50  80 110]
</span><span class='line'>for i in np.nditer(b,flags= ['external_loop'],order='C'):
</span><span class='line'>  print(i)
</span><span class='line'>[ 40  10  20  30  40  50  60  70  80  90 100 110]</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>广播迭代</h2>

<h4>如果两个数组是可广播的，nditer组合对象能够同时迭代它们。 假设数组a具有维度 3X4，并且存在维度为 1X4 的另一个数组b，则使用以下类型的迭代器(数组b被广播到a的大小)。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;&gt;&gt; a = a.reshape(3,4)
</span><span class='line'>&gt;&gt;&gt; a
</span><span class='line'>array([[ 40,  10,  20,  30],
</span><span class='line'>       [ 40,  50,  60,  70],
</span><span class='line'>       [ 80,  90, 100, 110]])
</span><span class='line'>&gt;&gt;&gt; b = np.array([1,  2,  3,  4], dtype =  int)
</span><span class='line'>&gt;&gt;&gt; b
</span><span class='line'>array([1, 2, 3, 4])
</span><span class='line'>&gt;&gt;&gt; for x,y in np.nditer([a,b]):
</span><span class='line'>  print('%d,%d'%(x,y))
</span><span class='line'>40,1
</span><span class='line'>10,2
</span><span class='line'>20,3
</span><span class='line'>30,4
</span><span class='line'>40,1
</span><span class='line'>50,2
</span><span class='line'>60,3
</span><span class='line'>70,4
</span><span class='line'>80,1
</span><span class='line'>90,2
</span><span class='line'>100,3
</span><span class='line'>110,4</span></code></pre></td></tr></table></div></figure>


<h4><a href="https://www.yiibai.com/numpy/numpy_array_attributes.html">https://www.yiibai.com/numpy/numpy_array_attributes.html</a></h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python_NumPy -NumPy - 广播⑨]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy10/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy10</id>
    <content type="html"><![CDATA[<h1>NumPy - 广播</h1>

<h4>术语广播是指 NumPy 在算术运算期间处理不同形状的数组的能力。 对数组的算术运算通常在相应的元素上进行。 如果两个阵列具有完全相同的形状，则这些操作被无缝执行。</h4>

<h4>如果两个数组的维数不相同，则元素到元素的操作是不可能的。 然而，在 NumPy 中仍然可以对形状不相似的数组进行操作，因为它拥有广播功能。 较小的数组会广播到较大数组的大小，以便使它们的形状可兼容。</h4>

<hr />

<h2>其实就是矩阵相加就是广播，但是矩阵只能是相同维数的相加，但是广播可以扩散到每一行上。</h2>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import numpy as np
</span><span class='line'>a = np.array([[0.0,0.0,0.0],[10.0,10.0,10.0],[20.0,20.0,20.0],[30.0,30.0,30.0]])
</span><span class='line'>a
</span><span class='line'>array([[ 0.,  0.,  0.],
</span><span class='line'>       [10., 10., 10.],
</span><span class='line'>       [20., 20., 20.],
</span><span class='line'>       [30., 30., 30.]])
</span><span class='line'>b = np.array([1.0,2.0])
</span><span class='line'>b
</span><span class='line'>array([1., 2.])
</span><span class='line'>a+b
</span><span class='line'>Traceback (most recent call last):
</span><span class='line'>  File "&lt;pyshell#6&gt;", line 1, in &lt;module&gt;
</span><span class='line'>    a+b
</span><span class='line'>ValueError: operands could not be broadcast together with shapes (4,3) (2,) 
</span><span class='line'>b = np.array([1.0,2.0,3.0])
</span><span class='line'>a+b
</span><span class='line'>array([[ 1.,  2.,  3.],
</span><span class='line'>       [11., 12., 13.],
</span><span class='line'>       [21., 22., 23.],
</span><span class='line'>       [31., 32., 33.]])
</span><span class='line'>c=np.array([[1.0],[2.0],[3.0]])
</span><span class='line'>c
</span><span class='line'>array([[1.],
</span><span class='line'>       [2.],
</span><span class='line'>       [3.]])
</span><span class='line'>a
</span><span class='line'>array([[ 0.,  0.,  0.],
</span><span class='line'>       [10., 10., 10.],
</span><span class='line'>       [20., 20., 20.],
</span><span class='line'>       [30., 30., 30.]])
</span><span class='line'>a+c
</span><span class='line'>Traceback (most recent call last):
</span><span class='line'>  File "&lt;pyshell#13&gt;", line 1, in &lt;module&gt;
</span><span class='line'>    a+c
</span><span class='line'>ValueError: operands could not be broadcast together with shapes (4,3) (3,1) 
</span><span class='line'>c=np.array([[1.0],[2.0],[3.0],[4.0]])
</span><span class='line'>c
</span><span class='line'>array([[1.],
</span><span class='line'>       [2.],
</span><span class='line'>       [3.],
</span><span class='line'>       [4.]])
</span><span class='line'>a+c
</span><span class='line'>array([[ 1.,  1.,  1.],
</span><span class='line'>       [12., 12., 12.],
</span><span class='line'>       [23., 23., 23.],
</span><span class='line'>       [34., 34., 34.]])</span></code></pre></td></tr></table></div></figure>


<h4>所以广播，一定要与维数较大的数组，如（A m<em>n），较小数组，要么行=m</em>1，要么列=1<em>n，只能是1维的，或者都相等m</em>n。</h4>

<h4><a href="https://www.yiibai.com/numpy/numpy_array_attributes.html">https://www.yiibai.com/numpy/numpy_array_attributes.html</a></h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python_numpy介绍与安装]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy1/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_numpy1</id>
    <content type="html"><![CDATA[<h1>NumPy</h1>

<hr />

<h2>NumPy - 简介</h2>

<h4>NumPy 是一个 Python 包。 它代表 “Numeric Python”。 它是一个由<code>多维数组对象和用于处理数组的例程集合组成的库</code>。</h4>

<hr />

<h2>NumPy 操作</h2>

<h4>使用NumPy，开发人员可以执行以下操作：</h4>

<ul>
<li><p>数组的算数和逻辑运算。</p></li>
<li><p>傅立叶变换和用于图形操作的例程。</p></li>
<li><p>与线性代数有关的操作。 NumPy 拥有线性代数和随机数生成的内置函数。</p></li>
</ul>


<hr />

<h2>NumPy环境安装配置</h2>

<h4>NumPy - 环境</h4>

<h4>启用 NumPy 的最佳方法是使用特定于您的操作系统的可安装的二进制包。 这些二进制包含完整的 SciPy 技术栈(包括 NumPy，SciPy，matplotlib，IPython，SymPy 以及 Python 核心自带的其它包)。</h4>

<h5>window安装</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip install numpy</span></code></pre></td></tr></table></div></figure>


<h5>linux 安装</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install python-numpy </span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试总结2]]></title>
    <link href="http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_mianshi2/"/>
    <updated>2018-07-03T15:11:11+08:00</updated>
    <id>http://shangyajun6943.github.io/blog/2018/07/03/shangyajunblog_mianshi2</id>
    <content type="html"><![CDATA[<h1>面试总结2</h1>

<hr />

<h5>内存泄漏和内存溢出的区别和联系</h5>

<h5>1、内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</h5>

<h5>2、内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</h5>

<h5>3、二者关系：</h5>

<ol>
<li>内存泄漏的堆积最终会导致内存溢出</li>
<li>内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。</li>
<li>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。</li>
<li>内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错，

<h5>4、内存泄漏的分类（按发生方式来分类）</h5></li>
<li>常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。</li>
<li>偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。</li>
<li>一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。</li>
<li>隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。</li>
</ol>


<h5>5、内存溢出的原因及解决方法：</h5>

<h5>内存溢出原因：</h5>

<ol>
<li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</li>
<li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；</li>
<li>代码中存在死循环或循环产生过多重复的对象实体；</li>
<li>使用的第三方软件中的BUG；</li>
<li>启动参数内存值设定的过小

<h5>内存溢出的解决方案：</h5>

<h5>第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</h5></li>
</ol>


<h5>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。</h5>

<h5>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。</h5>

<h4>重点排查以下几点：</h4>

<ol>
<li><p>检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</p></li>
<li><p>检查代码中是否有死循环或递归调用。</p></li>
<li><p>检查是否有大循环重复产生新对象实体。</p></li>
<li><p>检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</p></li>
</ol>


<h2><code>使用内存查看工具动态查看内存使用情况</code></h2>
]]></content>
  </entry>
  
</feed>
